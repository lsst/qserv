/*
 * LSST Data Management System
 * Copyright 2011-2018 LSST Corporation.
 *
 * This product includes software developed by the
 * LSST Project (http://www.lsst.org/).
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the LSST License Statement and
 * the GNU General Public License along with this program.  If not,
 * see <http://www.lsstcorp.org/LegalNotices/>.
 */

syntax = "proto2";

/**
 * replica.proto
 *   defines the wire-messages sent between replication controllers and
 *   worker services.
 */

package lsst.qserv.replica;


////////////////////////////////////////////////////////
//                  Request messages                  //
////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
// Protocol header sent to a worker. Any communication begins with
// sending this header and specifying a type of the request.
//
// Chunk replication requests must be followed by another message of
// the corresponding type to provide a scope of the request.
//
// Requests affecting the overall status of the service do not require
// any additional messages.

// Request types related to operations with replicas
//
enum ProtocolQueuedRequestType {

    REPLICA_CREATE   = 0;    // replicate a chunk
    REPLICA_DELETE   = 1;    // delete an existing replica of a chunk
    REPLICA_FIND     = 2;    // find out if a replica is present, and report its state
    REPLICA_FIND_ALL = 3;    // find all replicas and report their states
    TEST_ECHO        = 4;    // test the worker-side framework
    SQL              = 5;    // execute an SQL statement against the worker's database
    INDEX            = 6;    // extract and return a collection of the "director" index data
}

// Request types for managing above defined requests
//
enum ProtocolManagementRequestType {

    REQUEST_STATUS   = 0;   // check a status the previously submitted request
    REQUEST_STOP     = 1;   // stop the previously submitted request
    REQUEST_TRACK    = 2;   // track the previously submitted request
    REQUEST_DISPOSE  = 3;   // garbage collect the request (in-progress ones will be also stopped)
}

// Request types affecting the overall state of the worker replication service
//
enum ProtocolServiceRequestType {

    SERVICE_SUSPEND  = 0;
    SERVICE_RESUME   = 1;
    SERVICE_STATUS   = 2;
    SERVICE_REQUESTS = 3;
    SERVICE_DRAIN    = 4;
    SERVICE_RECONFIG = 5;
}

// Message header is sent next after the frame size request. A sender must
// indicate a class of a request by choosing one of a few options defined
// in 'Type', and then set the specific request in the corresponding
// optional field.
//
message ProtocolRequestHeader {

    /// The unique identifier of a request
    required string id = 1;

    // The request type selector determines which class of the below specified
    // optional subtypes to use
    enum RequestType {
        QUEUED  = 0;
        REQUEST = 1;
        SERVICE = 2;
    }
    required RequestType type = 2;

    // Subtypes of requests

    optional ProtocolQueuedRequestType     queued_type     = 3;
    optional ProtocolManagementRequestType management_type = 4;
    optional ProtocolServiceRequestType    service_type    = 5;

    /// Request expiration timeout (for queued requests only) for disposing
    /// requests regardless of their statuses. The timeout is expressed in
    /// seconds. The default value of '0' means no expiration for a request.
    optional uint32 timeout = 6 [default = 0];

    /// The priority level (for queued requests only) may affect a position of
    /// a request relative to others in the input queue of the worker processor.
    /// Requests with higher priority levels are placed close to the head
    /// of the queue.
    optional int32 priority = 7 [default = 0];

    /// A unique identifier of a Qserv instance served by the Replication System
    required string instance_id = 8;
}

//
// The type of the next message (if any) to be sent depends on  specific type of
// the operation. It should provide additional parameters of the operation.
//

// This is a replication request. The message defines a scope of the request and
// its unique identity. This message is sent once after the header.
//
message ProtocolRequestReplicate {

    required string database = 2;
    required uint32 chunk    = 3;
    required string worker   = 4;
    required string worker_host = 5;
    required uint32 worker_port = 6;    // Using extended range type to store the 16-bit unsigned due
                                        // to a lack of uint16 in the Protobuf. It's up to a client code
                                        // to ensure the actul value won't exceed the limitations of
                                        // the in-memory representations of the 16-bit unsigned type.
    required string worker_data_dir = 7;
}

// This is a replica deletion request. The message defines a scope of the request
// and its unique identity. This message is sent once after the header.
//
message ProtocolRequestDelete {

    required string database = 2;
    required uint32 chunk    = 3;
}

// This is a replica lookup request. The message defines a scope of the request
// and its unique identity. This message is sent once after the header.
//
message ProtocolRequestFind {

    required string database = 2;
    required uint32 chunk    = 3;

    /// Compute a check/control sum for each file
    required bool compute_cs = 4;
}

// This is a replica lookup request for multiple replicas. The message defines
// a scope of the request and its unique identity. This message is sent once
// after the header.
//
message ProtocolRequestFindAll {

    required string database = 2;
}

// This is a test request which, depending on its mode, would be addressed
// either instantly or be put into the Processor's queue. The desired mode
// is specified via the optional parameter 'delay'.
// This message is sent once after the header.
//
message ProtocolRequestEcho {

    /// Data to be echoed back upon the completion of the request (if successful)
    required string data = 2;

    /// The simulated processing time (milliseconds) of the request.
    /// If the delay is greater than 0 then the request will be queued for
    /// delayed processing via the Processor's queue.
    optional uint64 delay = 3 [default = 0];
}

// This message is used in the table schema definitions
message ProtocolRequestSqlColumn {
    required string name = 1;
    required string type = 2;
}

// This message is used in the index definitions
message ProtocolRequestSqlIndexColumn {
    required string name = 1;
    optional uint64 length = 2 [default = 0];
    optional bool ascending = 3 [default = true];
}

// This request is always queued.
// This message is sent once after the header for the 'SQL' request types
message ProtocolRequestSql {

    enum Type {
        QUERY = 0;
        CREATE_DATABASE = 1;
        DROP_DATABASE = 2;
        ENABLE_DATABASE = 3;    // in Qserv
        DISABLE_DATABASE = 4;   // in Qserv
        GRANT_ACCESS = 5;
        CREATE_TABLE = 6;
        DROP_TABLE = 7;
        REMOVE_TABLE_PARTITIONING = 8;
        DROP_TABLE_PARTITION = 9;
        GET_TABLE_INDEX = 10;
        CREATE_TABLE_INDEX = 11;
        DROP_TABLE_INDEX = 12;
        ALTER_TABLE = 13;
        TABLE_ROW_STATS = 14;
    }
    required Type type = 6;

    /// A limit for the maximum number of rows to be returned by a request.
    /// If the limit is exceeded then extended error code ProtocolStatusExt::LARGE_RESULT
    /// will be returned to a caller.
    required uint64 max_rows = 5;

    // Variable parameters of request types. Note, that a specific request would
    // only use a subset of those as needed.

    optional string query    = 2 [default = ""];    /// The query to be executed
    optional string user     = 3 [default = ""];    /// The name of a database user authorized in
                                                    /// a context of the query.
    optional string password = 4 [default = ""];    /// Database password for the user account
    optional string database = 7 [default = ""];    /// The name of a database
    optional string table    = 8 [default = ""];    /// The name of a table
    optional string engine   = 9 [default = ""];    /// The name of an MySQL engine

    optional string comment   = 20 [default = ""];  /// The comment for the table
    optional string charset   = 21 [default = ""];  /// The name of the default character set
    optional string collation = 22 [default = ""];  /// The name of the collations

    /// The name of a column (if any) which will be used as a key for MySQL partitions
    optional string partition_by_column = 10 [default = ""];

    optional uint32 transaction_id = 11 [default = 0];  /// An identifier of a super-transaction which
                                                        /// corresponds to a MySQL partition to be removed

    /// table schema
    repeated ProtocolRequestSqlColumn columns = 12;

    /// A collection of tables to apply an operation upon. This parameter is used
    /// for batch processing over multiple tables.
    repeated string tables = 13;

    /// This flag is used when a request to process multiple queries is made
    optional bool batch_mode = 14 [default = false];

    // Parameters of the index management operations

    enum IndexSpec {
        DEFAULT = 1;
        UNIQUE  = 2;
        FULLTEXT = 3;
        SPATIAL = 4;
    }
    optional IndexSpec index_spec = 15 [default = DEFAULT];
    optional string index_name = 16 [default = ""];
    optional string index_comment = 17 [default = ""];
    repeated ProtocolRequestSqlIndexColumn index_columns = 18;
    optional string alter_spec = 19 [default = ""];
}

// This request is always queued.
// This message is sent once after the header for the 'INDEX' request types
message ProtocolRequestDirectorIndex {

    required string database = 2;
    required string director_table = 6;
    required uint32 chunk = 3;
    required bool   has_transactions = 4;

    // An identifier of a super-transaction corresponding to a MySQL partition
    // to be inspected. This parameter is used only if the above defined
    // 'has_transactions' is set to 'true'.
    required uint32 transaction_id = 5;

    // The windowing parameters, where 'offset' specifies 0-based location
    // of the first byte.
    //
    // Please, note that the actual data extraction from the target table into the CSV
    // file at worker will be made when a request with 'offset' set to 0. Any subsequent
    // requests where a value of 'offset' will be higher will read the specified range of
    // bytes from an existing CSV file. The file will get deleted by the worker when it's
    // been fully read.
    optional uint64 offset = 7 [default = 0];
}

// This request is sent to stop an on-going request.
// This message is sent once after the header.
//
message ProtocolRequestStop {

    /// an identifier of a request to be stopped
    required string id = 1;
}

// This request is sent to track a status of a target request (if any
// is still in progress). This message is sent once after the header.
//
message ProtocolRequestTrack {

    /// an identifier of a request to be inspected
    required string id = 1;

    // A specific type of the request will affect a choice of the status
    // object returned in response. The type needs to match a value set
    // in the preceding header at: ProtocolRequestHeader::type

    optional ProtocolQueuedRequestType queued_type = 2;
}

// This request is sent to get a status of a target request (if any
// is still in progress). This message is sent once after the header.
//
message ProtocolRequestStatus {

    /// an identifier of a request to be inspected
    required string id = 1;
}

// This request is sent to explicitly require to garbage-collect a set
// of requests. The operation will happen regardless of states of
// the requests. Requests which are still in progress will be stopped before
// being disposed. This message is sent once after the header.
//
message ProtocolRequestDispose {

    /// an identifier of a request to be disposed
    repeated string ids = 1;
}

/////////////////////////////////////////////////////////
//                  Response messages                  //
/////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////
// All response sequences begin with sending the response
// header message containing a unique identifier of the original
// request.
//
// The header must be followed by one or more messages which are
// expected by the Controller in response to a preceding
// request associated with the original request.
//
message ProtocolResponseHeader {

    /// The unique identifier of the original request to which this
    /// response is being sent.
    required string id = 1;
}

/////////////////////////////////////////////////////////////
// These messages are expected by master upon a completion of
// the corresponding replication operations.

// Performance counters (timers) of the requests.
// This message must be present in the relevant replies.
//
message ProtocolPerformance {

    /// When a request was received by a worker service
    required uint64 receive_time = 1;

    /// When request execution started by a worker service
    required uint64 start_time = 2;

    /// When request execution finished by a worker service
    required uint64 finish_time = 3;
}

// Status values returned by all request related to operations with
// replicas. Request management operations always return messages whose types
// match the return types of the corresponding (original) replica-related requests.
// Service management requests have their own set of status values.
//
enum ProtocolStatus {
    CREATED       = 0;
    SUCCESS       = 1;
    QUEUED        = 2;
    IN_PROGRESS   = 3;
    IS_CANCELLING = 4;
    BAD           = 5;
    FAILED        = 6;
    CANCELLED     = 7;
}
enum ProtocolStatusExt {
    NONE = 0;                   // unspecified problem
    INVALID_PARAM = 1;          // invalid parameter(s) of a request
    INVALID_ID = 2;             // an invalid request identifier
    FOLDER_STAT = 4;            // failed to obtain fstat() for a folder
    FOLDER_CREATE = 5;          // failed to create a folder
    FILE_STAT = 6;              // failed to obtain fstat() for a file
    FILE_SIZE = 7;              // failed to obtain a size of a file
    FOLDER_READ = 8;            // failed to read the contents of a folder
    FILE_READ = 9;              // failed to read the contents of a file
    FILE_ROPEN = 10;            // failed to open a remote file
    FILE_CREATE = 11;           // failed to create a file
    FILE_OPEN = 12;             // failed to open a file
    FILE_RESIZE = 13;           // failed to resize a file
    FILE_WRITE = 14;            // failed to write into a file
    FILE_COPY = 15;             // failed to copy a file
    FILE_DELETE = 16;           // failed to delete a file
    FILE_RENAME = 17;           // failed to rename a file
    FILE_EXISTS = 18;           // file already exists
    SPACE_REQ = 19;             // space availability check failed
    NO_FOLDER = 20;             // folder doesn't exist
    NO_FILE = 21;               // file doesn't exist
    NO_ACCESS = 22;             // no access to a file or a folder
    NO_SPACE = 23;              // no space left on a device as required by an operation
    FILE_MTIME = 24;            // get/set 'mtime' operation failed
    MYSQL_ERROR = 25;           // general MySQL error (other than any specific ones listed here)
    LARGE_RESULT = 26;          // result exceeds a limit set in a request
    NO_SUCH_TABLE = 27;         // no table found while performing a MySQL operation
    NOT_PARTITIONED_TABLE = 28; // the table is not MySQL partitioned as it was expected
    NO_SUCH_PARTITION = 29;     // no MySQL partition found in a table as it was expected
    MULTIPLE = 30;              // multiple unspecified errors encountered when processing a request
    OTHER_EXCEPTION = 31;       // other exception not listed here
    FOREIGN_INSTANCE = 32;      // detected a request from a Controller serving an unrelated Qserv
    DUPLICATE_KEY = 33;         // duplicate key found when creating an index or altering a table schema
    CANT_DROP_KEY = 34;         // can't drop a field or a key which doesn't exist
}

message ProtocolFileInfo {

    /// The name of a file
    required string name = 1;

    /// Size in bytes
    required uint64 size = 2;

    /// Control sum (if available)
    required string cs = 3;

    /// The file content modification time in seconds (since UNIX Epoch)
    required uint32 mtime = 4;

    // The following parameters are set in the relevant contexts only.
    // Otherwise they'll be set to some default value)

    /// When the file migration started (where applies)
    optional uint64 begin_transfer_time = 5 [default = 0];

    /// When the file migration finished (where applies)
    optional uint64 end_transfer_time = 6 [default = 0];

    /// The size of an input file (where applies)
    optional uint64 in_size = 7 [default = 0];
}

message ProtocolReplicaInfo {
    enum ReplicaStatus {
        NOT_FOUND  = 0;
        CORRUPT    = 1;
        INCOMPLETE = 2;
        COMPLETE   = 3;
    }
    required ReplicaStatus status   = 1;
    required string        worker   = 2;
    required string        database = 3;
    required uint32        chunk    = 4;

    /// File-specific information (if available)
    repeated ProtocolFileInfo file_info_many = 5;

    /// When the replica status was obtained by a worker
    required uint64 verify_time = 6;
}

message ProtocolResponseReplicate {

    /// The completion status of the operation
    required ProtocolStatus status = 8;

    /// Extended status of this operation
    optional ProtocolStatusExt status_ext = 2 [default = NONE];

    /// The performance of this operation
    required ProtocolPerformance performance = 4;

    // ------------------------------------------------------------------
    // The following optional fields are set upon a successful completion
    // of the request
    // ------------------------------------------------------------------

    /// The performance of the target operation. This field represents
    /// stats of the replica creation request obtained by the request
    /// management operations.
    optional ProtocolPerformance target_performance = 5;

    /// Extended information on the replica
    optional ProtocolReplicaInfo replica_info = 6;

    /// Parameters of the original request to which this response
    /// is related.
    optional ProtocolRequestReplicate request = 7;
}

message ProtocolResponseDelete {

    /// The completion status of the operation
    required ProtocolStatus status = 8;

    /// Extended status of this operation
    optional ProtocolStatusExt status_ext = 2 [default = NONE];

    /// The performance of this operation
    required ProtocolPerformance performance = 4;

    // ------------------------------------------------------------------
    // The following optional fields are set upon a successful completion
    // of the request
    // ------------------------------------------------------------------

    /// The performance of the target operation. This field represents
    /// stats of the replica deletion request obtained by the request
    /// management operations
    optional ProtocolPerformance target_performance = 5;

    /// Extended information on the request
    optional ProtocolReplicaInfo replica_info = 6;

    /// Parameters of the original request to which this response
    /// is related
    optional ProtocolRequestDelete request = 7;

}

message ProtocolResponseFind {

    /// The completion status of the operation
    required ProtocolStatus status = 7;

    /// Extended status of this operation
    optional ProtocolStatusExt status_ext = 2 [default = NONE];

    /// The performance of this operation
    required ProtocolPerformance performance = 3;

    // ------------------------------------------------------------------
    // The following optional fields are set upon a successful completion
    // of the request
    // ------------------------------------------------------------------

    /// The performance of the target operation. This field represents
    /// stats of the replica deletion request obtained by the request
    /// management operations
    optional ProtocolPerformance target_performance = 4;

    /// Extended information on the request
    optional ProtocolReplicaInfo replica_info = 5;

    /// Parameters of the original request to which this response
    /// is related
    optional ProtocolRequestFind request = 6;
}

message ProtocolResponseFindAll {

    /// The completion status of the operation
    required ProtocolStatus status = 7;

    /// Extended status of this operation
    optional ProtocolStatusExt status_ext = 2 [default = NONE];

    /// The performance of this operation
    required ProtocolPerformance performance = 3;

    /// The performance of the target operation. This field represents
    /// stats of the replicas lookup request obtained by the request
    /// management operations
    optional ProtocolPerformance target_performance = 4;

    /// Extended information on the request
    repeated ProtocolReplicaInfo replica_info_many = 5;

    // ------------------------------------------------------------------
    // The following optional fields are set upon a successful completion
    // of the request
    // ------------------------------------------------------------------

    /// Parameters of the original request to which this response
    /// is related
    optional ProtocolRequestFindAll request = 6;
}

///////////////////////////////////////////////////////////////////
// The message returned in response to the worker testing requests.

message ProtocolResponseEcho {

    /// The completion status of the operation
    required ProtocolStatus status = 7;

    /// Extended status of this operation
    optional ProtocolStatusExt status_ext = 2 [default = NONE];

    /// The performance of this operation
    required ProtocolPerformance performance = 3;

    // -----------------------------------------------------------------
    // The following optional field are set upon a successful completion
    // of the request
    // -----------------------------------------------------------------

    /// The performance of the target operation. This field represents stats
    /// of the test request obtained by the request management operations.
    optional ProtocolPerformance target_performance = 4;

    /// Extended information on the request
    optional string data = 5;

    /// Parameters of the original request to which this response is related
    optional ProtocolRequestEcho request = 6;
}

/////////////////////////////////////////////////////////////////////
// The messages returned in response to an SQL query executed against 
// the worker's database

/// This message captures fields from MYSQL_FIELD

message ProtocolResponseSqlField {
                                        // C lang type(s)         Description
                                        // --------------------   ---------------------------------------------
    required string name       =  1;    // char*, unsigned int    The name of the column
    required string org_name   =  2;    // char*, unsigned int    The original name of the column
    required string table      =  3;    // char*, unsigned int    The name of the table
    required string org_table  =  4;    // char*, unsigned int    The original name of the table
    required string db         =  5;    // char*, unsigned int    The name of the database (schema)
    required string catalog    =  6;    // char*, unsigned int    The catalog name (always 'def')
    required string def        =  7;    // char*, unsigned int    default value
    required uint32 length     =  8;    // unsigned int           The length (width) of the column definition
    required uint32 max_length =  9;    // unsigned int           The maximum length of the column value
    required uint32 flags      = 10;    // unsigned int           Flags
    required uint32 decimals   = 11;    // unsigned int           Number of decimals
    required int32  type       = 12;    // enum enum_field_types  Field type. See all known types at:
                                        //                        https://dev.mysql.com/doc/refman/8.0/en/c-api-data-structures.html
}

/// The message representing data of a row from a result set
message ProtocolResponseSqlRow {

    /// An array of the raw (non-null terminated) byte strings, where each string
    /// represents a cell.
    /// Note that the number of elements in the array must match
    /// the number of fields.
    repeated bytes cells = 1;

    /// An array of the boolean flags indicating at which position a value
    /// of the corresponding cell has SQL NULL.
    /// Note that the number of elements in the array must match
    /// the number of fields.
    repeated bool nulls = 2;
}

message ProtocolResponseSqlResultSet {

    /// This parameter defines a scope of an operation over a worker database,
    /// and its meaning varies depending on the operation. It could be the name
    /// of a table, the name of a database, or a query. 
    optional string scope = 1 [default = ""];

    /// Extended status of an operation in a scope of a query. It needs to be
    /// explicitly set for queries with a different outcome (if they succeeded
    /// or failed due to a specific problem). The successful completion of a query
    /// is indicated by status set to NONE.
    optional ProtocolStatusExt status_ext = 2 [default = MYSQL_ERROR];

    /// MySQL-specific error (if any)
    optional string error = 3 [default = ""];

    /// Of the connection
    optional string char_set_name = 4 [default = ""];

    /// The request produced a result set
    optional bool has_result = 5;

    /// A vector with field definitions from a result set,
    /// where the number of objects in the array represents
    /// the "width" of the result set
    repeated ProtocolResponseSqlField fields = 6;

    /// An array of rows from a result set,
    /// where the number of elements in the array represents
    /// the number of rows.
    repeated ProtocolResponseSqlRow rows = 7;
}

message ProtocolResponseSql {

    /// The completion status of the operation
    required ProtocolStatus status = 12;

    /// Extended status of an operation
    optional ProtocolStatusExt status_ext = 2 [default = NONE];

    /// The performance of this operation
    required ProtocolPerformance performance = 3;

    // -----------------------------------------------------------------
    // The following optional field are set upon a successful completion
    // of the request
    // -----------------------------------------------------------------

    /// The performance of the target operation. This field represents stats
    /// of the test request obtained by the request management operations.
    optional ProtocolPerformance target_performance = 4;

    // Extended information on the request

    /// Result sets for the operations
    repeated ProtocolResponseSqlResultSet result_sets = 11;

    /// Parameters of the original request to which this response is related
    optional ProtocolRequestSql request = 10;
}

message ProtocolResponseDirectorIndex {

    /// The completion status of the operation
    required ProtocolStatus status = 8;

    /// Extended status of this operation
    optional ProtocolStatusExt status_ext = 2 [default = NONE];

    /// The performance of this operation
    required ProtocolPerformance performance = 3;

    // ------------------------------------------------------------------
    // The following optional fields are set upon a successful completion
    // of the request
    // ------------------------------------------------------------------

    /// The performance of the target operation. This field represents
    /// stats of the original request obtained by the request
    /// management operations
    optional ProtocolPerformance target_performance = 4;

    /// MySQL-specific error
    optional string error = 5 [default = ""];

    /// Partial content of the TSV/CSV file in which is lines has a set of fields
    /// to be ingested into the "director" index at Qserv master. The number and
    /// a schema of fields depends on a mode the request was made as well as on
    /// a mode of the request. For consolidated (not MySQL partitioned tables)
    /// each line of the file would be represented by the triplet:
    ///
    ///   <object-id> <chunk-id> <sub-chunk-id>
    ///
    /// An for the MySQL partitioned tables it would be the quadruplet:
    ///
    ///   <super-transaction-id> <object-id> <chunk-id> <sub-chunk-id>
    ///
    required bytes data = 6;

    /// The total number of bytes in the CSV file.
    required uint64 total_bytes = 9;

    /// Parameters of the original request to which this response
    /// is related
    optional ProtocolRequestDirectorIndex request = 7;
}

message ProtocolResponseDisposeStatus {
    required string id = 1;
    required bool disposed = 2; 
}

message ProtocolResponseDispose {
    repeated ProtocolResponseDisposeStatus ids = 1;

    /// The completion status of the operation
    optional ProtocolStatus status = 4 [default = SUCCESS];

    /// Extended status of this operation
    optional ProtocolStatusExt status_ext = 3 [default = NONE];
}

message ProtocolResponseStop {

    /// The completion status of the operation
    required ProtocolStatus status = 8;

    /// Extended status of this operation
    optional ProtocolStatusExt status_ext = 2 [default = NONE];

    /// The performance of this operation
    required ProtocolPerformance performance = 4;
}

message ProtocolResponseStatus {

    /// The completion status of the operation
    required ProtocolStatus status = 1;

    /// Extended status of this operation
    optional ProtocolStatusExt status_ext = 2 [default = NONE];

    /// The performance of this operation
    required ProtocolPerformance performance = 3;

    // The following atributes are set only if the target request was found at the worker.
    // Otherwise, there is no point in setting any default values of the attributes.

    /// The completion status of the target request
    optional ProtocolStatus target_status = 4;

    /// Extended status of the target request
    optional ProtocolStatusExt target_status_ext = 5;

    /// The performance of the target request
    optional ProtocolPerformance target_performance = 6;

}

/////////////////////////////////////////////////////////////////////////
// The message returned in response to requests related to (or affecting)
// the overall state of the server-side replication service.

message ProtocolServiceResponseInfo {

    /// Replication related requests only
    required ProtocolQueuedRequestType queued_type = 1;

    required string id       = 2;
    required int32  priority = 3;
}

message ProtocolServiceResponse {

    /// The completion status of the operation
    required ProtocolStatus status = 14;

    /// Extended status of this operation
    optional ProtocolStatusExt status_ext = 13 [default = NONE];

    required ProtocolPerformance performance = 2;

    enum ServiceState {
        SUSPEND_IN_PROGRESS = 0;
        SUSPENDED           = 1;
        RUNNING             = 2;
    }
    required ServiceState service_state = 3;

    /// When the service started (milliseconds since UNIX Epoch)
    required uint64 start_time = 5;

    // Counters for requests known to the service since its last start

    required uint32 num_new_requests         = 6;
    required uint32 num_in_progress_requests = 7;
    required uint32 num_finished_requests    = 8;

    // Optional (depending on a request) collections of requests in each queue

    repeated ProtocolServiceResponseInfo new_requests         =  9;
    repeated ProtocolServiceResponseInfo in_progress_requests = 10;
    repeated ProtocolServiceResponseInfo finished_requests    = 11;
}

////////////////////////////////////////////
//         The FileServer protocol        //
////////////////////////////////////////////

message ProtocolFileRequest {

    /// The name of a database
    required string database = 1;

    /// The name of a file (including its extension and excluding any path)
    required string file = 2;

    /// Tell the server to begin sending file content immediately
    /// after sending the response message. Otherwise the server will just
    /// close a connection.
    required bool send_content = 3;

    /// A unique identifier of a Qserv instance served by the Replication System
    required string instance_id = 4;
}

message ProtocolFileResponse {

    /// The flag indicating if the earlier requested file is available,
    /// and it can be read by the server.
    required bool available = 1;

    /// The file size (bytes)
    required uint64 size = 2;

    /// The file content modification time in seconds (since UNIX Epoch)
    required uint32 mtime = 3;

    /// The flag which if set indicates if the worker and the server belong
    /// to different Qserv instances.
    optional bool foreign_instance = 4 [default = false];
}

//////////////////////////////////////////////
//         The IngestServer protocol        //
//////////////////////////////////////////////

/// Parameters related to a format of the input CSV/TSV files. For further explanation
/// see MySQL documentation at: https://dev.mysql.com/doc/refman/8.0/en/load-data.html
/// Note that values of the parameters will be parsed and validated by the server.
message ProtocolDialectInput {
    required string fields_terminated_by = 1;
    required string fields_enclosed_by = 2;
    required string fields_escaped_by = 3;
    required string lines_terminated_by = 4;
}

/// Sent once by a client after establishing a connection with a server
message ProtocolIngestHandshakeRequest {

    /// An identifier of a super-transaction
    required uint32 transaction_id = 1;

    /// The base name (no chunk numbers or 'overlap' suffixes) of table to be loaded
    required string table = 2;

    /// The chunk number
    required uint32 chunk = 3;

    /// The flag indicating if this is the chunk 'overlap' table
    required bool is_overlap = 4;

    /// An authorization key which should match the one known to a server
    optional string auth_key = 6 [default = ""];

    /// The file URL for bookkeeping. The URL is expected to include the name of
    /// the client's host: 'file://<host>/<path>'.
    required string url = 7;

    /// The input parameteres for a dialect of the input file.
    required ProtocolDialectInput dialect_input = 12;

    /// The optional limit for the number of MySQL warnings to be captured
    /// after loading the contribution. In case of the default value of 0
    /// is used the limit will be derived from the corresponding
    /// configuration parameter.
    optional uint32 max_num_warnings = 13 [default = 0];

    /// The optional name of a charset to be usd when loading
    /// the contribution into the destination table.
    optional string charset_name = 14 [default = ""];
}

/// A message which is meant for sending a byte stream to a server after receiving
/// status READY_TO_READ_DATA. This message is sent once after each READY_TO_READ_DATA.
/// When sending the last batch of the data the client should set the flag 'last' to
/// to tell the server that no more data are available. In that case the server
/// should respond with FINISHED. Then both parties should close the connection.
message ProtocolIngestData {
    required bytes data = 1;
    required bool last = 2;     /// 'true' if this was the last batch of rows
}

/// The response message sent by a server on each client's request
message ProtocolIngestResponse {

    required uint64 id = 8;     /// the unique identifier of the contribution request

    enum Status {
        READY_TO_READ_DATA = 0;     /// server is waiting for data
        FINISHED           = 1;     /// a confirmation that the file content accepted
        FAILED             = 2;     /// to report problems
    }
    required Status status = 1;

    optional string error = 3 [default = ""];           /// sent with FAILED
    optional bool retry_allowed = 4 [default = false];  /// sent with FAILED
    optional uint32 num_warnings = 5 [default = 0];     /// sent with FINISHED
    optional uint64 num_rows = 6 [default = 0];         /// sent with FINISHED
    optional uint64 num_rows_loaded = 7 [default = 0];  /// sent with FINISHED
}

//////////////////////////////////////////////
//         The ExportServer protocol        //
//////////////////////////////////////////////

/// Sent once by a client after establishing a connection with a server.
/// The server is expected to response with ProtocolExportHandshakeResponse.

message ProtocolExportHandshakeRequest {

    /// The name of a database
    required string database = 1;

    /// The base name (no chunk numbers or 'overlap' suffixes) of a table
    /// to be exported.
    required string table = 2;

    /// The chunk number (for partitioned tables only)
    optional uint32 chunk = 3 [default = 0];

    /// The flag indicating if this is the chunk 'overlap' table
    //// (for partitioned tables only)
    optional bool is_overlap = 4 [default = false];

    /// A character separating columns within a row
    enum ColumnSeparator {
        COMMA = 0;
        TAB   = 1;
    }
    optional ColumnSeparator column_separator = 5 [default = COMMA];

    /// An authorization key which should match the one known to a server
    optional string auth_key = 6 [default = ""];
}

/// The response message is sent once by a server to a client to indicate
/// that a table dump has been successfully obtained and the server is ready
/// to send data, or in case if any problem with the request's parameters or
/// its implementation occurred.
///
/// In the former case the the server should send back the number of bytes in
/// the table dump, so that the client could use this information for various purposes,
/// such as tracking a progress of the operation. Otherwise a non-empty error
/// string will be returned in the corresponding field of the message.
///
/// The client is expected to begin requesting table data by sending ProtocolExportRequest.

message ProtocolExportHandshakeResponse {

    /// Non-empty if the operation failed
    optional string error = 1 [default = ""];

    /// The amount of data in the table dump
    optional uint64 file_size = 2 [default = 0];
}

/// The request message sent by a client to a server to indicate it's ready
/// to receive the next set of rows. The server is expected to respond with
/// message ProtocolExportResponse.

message ProtocolExportRequest {

    enum Status {
        READY_TO_READ_DATA = 0;     /// client is waiting for data
        FINISHED           = 1;     /// a confirmation that the file content accepted,
                                    /// or when the client wants to abort the operation.
    }
    required Status status = 1;

    /// The advised number of rows in the server's response. This parameter
    /// is used for the flow control in the protocol.
    optional uint32 max_rows = 2 [default = 1]; /// sent with READY_TO_READ_DATA
}


/// A message which is meant for sending rows to a client after receiving
/// a message ProtocolExportRequest with status set to READY_TO_READ_DATA.
/// This message is sent once after each READY_TO_READ_DATA.
/// When sending the last batch of rows the server should set the flag 'last' to
/// to tell the client that no more data are available. In that case the client
/// should respond with FINISHED. Then both parties should close the connection.

message ProtocolExportResponse {

    /// Non-empty if the operation failed
    optional string error = 1 [default = ""];

    /// Set to 'true' if this was the last batch of rows
    optional bool last = 2 [default = false];

    /// The payload of the request. Note that this is the binary stream of bytes
    /// obtained from the dump file.
    repeated bytes rows = 3;
}
