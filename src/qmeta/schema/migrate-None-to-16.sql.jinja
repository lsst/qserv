--
-- Script to initialize the QMeta database
--

CREATE USER IF NOT EXISTS '{{ mysqld_user_qserv }}'@'localhost' IDENTIFIED BY "{{ mysqld_user_qserv_password }}";
CREATE USER IF NOT EXISTS '{{ mysqld_user_qserv }}'@'%' IDENTIFIED BY "{{ mysqld_user_qserv_password }}";

-- Director index database (i.e. objectId/chunkId relation)
-- created by integration test script/loader for now
CREATE DATABASE IF NOT EXISTS qservMeta;
GRANT ALL ON qservMeta.* TO '{{ mysqld_user_qserv }}'@'localhost';
GRANT ALL ON qservMeta.* TO '{{ mysqld_user_qserv }}'@'%';

-- -----------------------------------------------------
-- Schema qservMeta
-- -----------------------------------------------------
CREATE SCHEMA IF NOT EXISTS `qservMeta` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci ;
USE `qservMeta` ;

-- -----------------------------------------------------
-- Table `QCzar`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `QCzar` (
  `czarId` INT NOT NULL AUTO_INCREMENT COMMENT 'Czar identifier',
  `czar` CHAR(63) NOT NULL COMMENT 'Czar unique name',
  `active` BIT NOT NULL COMMENT 'Set to 0 when czar disappears',
  PRIMARY KEY (`czarId`),
  UNIQUE INDEX `QCzar_czar_UNIQUE` (`czar` ASC))
ENGINE = InnoDB
COMMENT = 'Table for czars, definition of every czar ever existed.';


-- -----------------------------------------------------
-- Table `QInfo`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `QInfo` (
  `queryId` BIGINT NOT NULL AUTO_INCREMENT COMMENT 'Query identifier, unique number',
  `qType` ENUM('SYNC', 'ASYNC') NOT NULL COMMENT 'Query type, either SYNC or ASYNC.',
  `czarId` INT NOT NULL COMMENT 'ID of the \"responsible czar\" of this query',
  `user` CHAR(63) NOT NULL COMMENT 'Name (id) of the user submitting this query',
  `query` MEDIUMTEXT NOT NULL COMMENT 'Original query text as was submitted by client.',
  `qTemplate` MEDIUMTEXT NOT NULL COMMENT 'Query template, string used to build final per-chunk query.',
  `qMerge` MEDIUMTEXT NULL COMMENT 'Merge (or aggregate) query to be executed on results table, result of this query is stored in merge table. If NULL then it is equivalent to SELECT *.',
  `status` ENUM('EXECUTING', 'COMPLETED', 'FAILED', 'FAILED_LR', 'ABORTED') NOT NULL DEFAULT 'EXECUTING' COMMENT 'Status of query processing.',
  `submitted` TIMESTAMP NOT NULL DEFAULT  CURRENT_TIMESTAMP COMMENT 'Time when query was submitted (received from client)',
  `completed` TIMESTAMP NULL COMMENT 'Time when query processing is completed - either the results were collected into czar-side result table or failure is detected.',
  `returned` TIMESTAMP NULL COMMENT 'Time when result is sent back to user. NULL if not completed yet.',
  `messageTable` CHAR(63) NULL COMMENT 'Name of the message table for the ASYNC query',
  `resultLocation` TEXT NULL COMMENT 'Result destination - table name, file name, etc.',
  `resultQuery` MEDIUMTEXT NULL COMMENT 'Query to be used by mysqlproxy to get final results.',
  `chunkCount` INT NOT NULL COMMENT 'number of chunks needed by the query',
  `collectedBytes` BIGINT DEFAULT 0 COMMENT 'number of bytes collected from workers',
  `collectedRows` BIGINT DEFAULT 0 COMMENT  'number of rows collected from workers',
  `finalRows` BIGINT DEFAULT 0 COMMENT  'number of rows in the final result',
  PRIMARY KEY (`queryId`),
  KEY `QInfo_czarId_index` (`czarId`),
  KEY `QInfo_status_index` (`status`),
  KEY `QInfo_submitted_index` (`submitted`),
  KEY `QInfo_completed_index` (`completed`),
  KEY `QInfo_returned_index` (`returned`),
  KEY `QInfo_qtype_index` (`qType`),
  CONSTRAINT `QInfo_cid`
    FOREIGN KEY (`czarId`)
    REFERENCES `QCzar` (`czarId`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Table containing per-query information.';


-- -----------------------------------------------------
-- Table `QTable`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `QTable` (
  `queryId` BIGINT NOT NULL COMMENT 'Query identifier, foreign key into QueryInfo table',
  `dbName` CHAR(63) NOT NULL COMMENT 'Database name',
  `tblName` CHAR(63) NOT NULL COMMENT 'Table name',
  PRIMARY KEY (`queryId`, `dbName`, `tblName`),
  INDEX `QTable_TableNameIndex` (`dbName` ASC, `tblName` ASC),
  CONSTRAINT `QTable_qid`
    FOREIGN KEY (`queryId`)
    REFERENCES `QInfo` (`queryId`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Table containing table names used by query.';

-- -----------------------------------------------------
-- Table `QProgress`
-- MEMORY table - will be recreated(but empty) by mariadb every time server starts.
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `QProgress` (
  `queryId` BIGINT NOT NULL COMMENT 'Query ID',
  `totalChunks` INT COMMENT 'Total number of chunks in the query',
  `completedChunks` INT COMMENT 'Number of completed chunks in the query',
  `queryBegin` TIMESTAMP DEFAULT 0 COMMENT 'When the query was started',
  `lastUpdate` TIMESTAMP DEFAULT 0 COMMENT 'Last time completedChunks was updated',
  PRIMARY KEY (`queryId`),
  CONSTRAINT `fk_queryId` FOREIGN KEY (`queryId`) REFERENCES `QInfo` (`queryId`) ON DELETE CASCADE ON UPDATE CASCADE)
ENGINE = MEMORY
COMMENT = 'Table to track chunk processing progress of the running queries.';

-- -----------------------------------------------------
-- Table `QProgressHistory`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `QProgressHistory` (
  `queryId` BIGINT NOT NULL COMMENT 'Query ID',
  `history` MEDIUMTEXT COMMENT 'Serialized JSON object representing the latest state of the history',
  `begin` BIGINT UNSIGNED NOT NULL COMMENT 'The timestamp (milliseconds since UNIX Epoch) of the first point in the history',
  `end` BIGINT UNSIGNED NOT NULL COMMENT 'The timestamp (milliseconds since UNIX Epoch) of the last point in the history',
  `totalPoints` INT UNSIGNED NOT NULL COMMENT 'The total number of points in the history',
  PRIMARY KEY (`queryId`),
  INDEX `idx_begin` (`begin` ASC),
  INDEX `idx_end` (`end` ASC),
  INDEX `idx_totalPoints` (`totalPoints` ASC),
  CONSTRAINT `fk_queryId` FOREIGN KEY (`queryId`) REFERENCES `QInfo` (`queryId`) ON DELETE CASCADE ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Table to store the query progression history.';

-- ----------------------------------------------------------------------------------------
-- View `InfoSchemaProcessList`
-- This shows full Qmeta info suitable for "SELECT ... FROM INFORMATION_SCHEMA.PROCESSLIST"
-- ----------------------------------------------------------------------------------------
CREATE OR REPLACE
  SQL SECURITY INVOKER
  VIEW `InfoSchemaProcessList` AS
  SELECT `qi`.`queryId` `ID`,
         `qi`.`qType` `TYPE`,
         `qc`.`czar` `CZAR`,
         `qc`.`czarId` `CZAR_ID`,
         `qi`.`submitted` `SUBMITTED`,
         `qs`.`lastUpdate` `UPDATED`,
         `qi`.`chunkCount` `CHUNKS`,
         `qs`.`completedChunks` `CHUNKS_COMP`,
         `qi`.`query` `QUERY`
    FROM `QInfo` AS `qi`
    LEFT OUTER JOIN `QProgress` AS `qs` ON `qi`.`queryId`=`qs`.`queryId`
    JOIN `QCzar` AS `qc` ON `qi`.`czarId`=`qc`.`czarId`
    WHERE `qi`.`status` = 'EXECUTING';

-- -----------------------------------------------------
-- Table `QMessages`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `QMessages` (
  `queryId` BIGINT NOT NULL COMMENT 'Query identifier, foreign key into QueryInfo table',
  `msgSource` VARCHAR(63) NOT NULL COMMENT 'Brief string describing the source PARSE, COMM, WORKER, etc',
  `chunkId` INT COMMENT 'chunkId',
  `code` SMALLINT COMMENT 'Error code',
  `message` MEDIUMTEXT NOT NULL COMMENT 'Message generated while executing queryId',
  `severity` VARCHAR(256) NOT NULL COMMENT 'severity of the message INFO or ERROR',
  `timestamp` BIGINT UNSIGNED NOT NULL COMMENT 'time of error message in milliseconds',
  INDEX `QMessages_qId_idx` (`queryId`),
  CONSTRAINT `QMessages_qid_fkey`
    FOREIGN KEY (`queryId`)
    REFERENCES `QInfo` (`queryId`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Table of messages generated during queries.';

-- ------------------------------------------------------------------------------------
-- View `InfoSchemaQueries`
-- This shows full Qmeta info suitable for "SELECT ... FROM INFORMATION_SCHEMA.QUERIES"
-- ------------------------------------------------------------------------------------
CREATE OR REPLACE
  SQL SECURITY INVOKER
  VIEW `InfoSchemaQueries` AS
  SELECT `qi`.`queryId` `ID`,
         `qi`.`qType` `TYPE`,
         `qc`.`czar` `CZAR`,
         `qc`.`czarId` `CZAR_ID`,
         `qi`.`status` `STATUS`,
         `qi`.`submitted` `SUBMITTED`,
         `qi`.`completed` `COMPLETED`,
         `qi`.`returned` `RETURNED`,
         `qi`.`chunkCount` `CHUNKS`,
         `qi`.`collectedBytes` `BYTES`,
         `qi`.`collectedRows` `ROWS_COLLECTED`,
         `qi`.`finalRows` `ROWS`,
         GROUP_CONCAT(DISTINCT `qt`.`dbName`) `DBS`,
         `qi`.`query` `QUERY`,
         TRIM(BOTH ',' FROM GROUP_CONCAT(IF(`qm`.`severity`='ERROR',`qm`.`message`,''))) `ERROR`
    FROM `QInfo` AS `qi`
    JOIN `QCzar` AS `qc` ON `qi`.`czarId`=`qc`.`czarId`
    LEFT OUTER JOIN `QTable` AS `qt` ON `qi`.`queryId`=`qt`.`queryId`
    LEFT OUTER JOIN `QMessages` AS `qm` ON `qi`.`queryId`=`qm`.`queryId`
    GROUP BY `qi`.`queryId`;

-- -----------------------------------------------------
-- Table `chunkMap`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `chunkMap` (
  `worker` VARCHAR(256) NOT NULL COMMENT 'A unique identifier of a worker hosting the chunk replica',
  `database` VARCHAR(256) NOT NULL COMMENT 'The name of a database',
  `table` VARCHAR(256) NOT NULL COMMENT 'The name of a table',
  `chunk` INT UNSIGNED NOT NULL COMMENT 'The number of a chunk',
  `size` BIGINT UNSIGNED NOT NULL COMMENT 'The size of a chunk')
ENGINE = InnoDB
COMMENT = 'Chunk disposition across workers';

-- -----------------------------------------------------
-- Table `chunkMapStatus`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `chunkMapStatus` (
  `update_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 'The most recent update time of the map')
ENGINE = InnoDB
COMMENT = 'Satus info on the chunk map';

-- -----------------------------------------------------
-- Table `UserTables`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `UserTables` (
  `id` INT UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'A unique identifier of the ingest request',
  `status` ENUM('IN_PROGRESS','COMPLETED','FAILED','FAILED_LR') DEFAULT 'IN_PROGRESS' COMMENT 'The status of the request',
  `begin_time` BIGINT UNSIGNED NOT NULL COMMENT 'The timestamp (ms) since UNIX Epoch when the request processing started',
  `end_time` BIGINT UNSIGNED DEFAULT 0 COMMENT 'The timestamp (ms) since UNIX Epoch when the request processing finished or failed',
  `delete_time` BIGINT UNSIGNED DEFAULT 0 COMMENT 'The timestamp (ms) since UNIX Epoch when the temporary table/database was deleted',
  `error` TEXT DEFAULT '' COMMENT 'The error message explaining reasons why the request failed',
  `database` VARCHAR(64) NOT NULL COMMENT 'The name of a database',
  `table` VARCHAR(64) NOT NULL COMMENT 'The name of a table',
  `table_type` ENUM('FULLY_REPLICATED','DIRECTOR','CHILD','REF_MATCH') NOT NULL COMMENT 'The type of the table',
  `is_temporary` TINYINT(1) NOT NULL COMMENT 'The flag indicating if the table is temporary and is expected to be deleted after use (FULLY_REPLICATED tables only)',
  `data_format` ENUM('CSV','JSON','PARQUET') NOT NULL COMMENT 'The format of the input data',
  `num_chunks` INT UNSIGNED DEFAULT 0 COMMENT 'The number of chunks ingested (0 for FULLY_REPLICATED tables)',
  `num_rows` BIGINT UNSIGNED DEFAULT 0 COMMENT 'The number of rows in the input file',
  `num_bytes` BIGINT UNSIGNED DEFAULT 0 COMMENT 'The number of bytes in the input file',
  `transaction_id` INT UNSIGNED DEFAULT 0 COMMENT 'The transaction ID (Replication/Ingest system)',
  PRIMARY KEY (`id`),
  INDEX `idx_database` (`database` ASC),
  INDEX `idx_table` (`table` ASC),
  INDEX `idx_begin_time` (`begin_time` ASC),
  INDEX `idx_end_time` (`end_time` ASC),
  INDEX `idx_status` (`status` ASC)
)
ENGINE = InnoDB
COMMENT = 'A registry for the user table ingest requests';

-- -----------------------------------------------------
-- Table `UserTablesParams`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `UserTablesParams` (
  `id` INT UNSIGNED NOT NULL COMMENT 'A unique identifier of the ingest request',
  `key` VARCHAR(256) NOT NULL COMMENT 'The name of a parameter',
  `val` MEDIUMTEXT NOT NULL COMMENT 'The value of a parameter',
  INDEX `idx_id` (`id` ASC),
  INDEX `idx_key` (`key` ASC),
  CONSTRAINT `fk_id`
    FOREIGN KEY (`id`)
    REFERENCES `UserTables` (`id`)
    ON DELETE CASCADE
    ON UPDATE CASCADE
)
ENGINE = InnoDB
COMMENT = 'Extended parameters of the table ingest requests';

-- -----------------------------------------------------
-- Table `QMetadata`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `QMetadata` (
  `metakey` CHAR(64) NOT NULL COMMENT 'Key string',
  `value` TEXT NULL COMMENT 'Key string',
  PRIMARY KEY (`metakey`))
ENGINE = InnoDB
COMMENT = 'Metadata about database as a whole, bunch of key-value pairs';

-- -----------------------------------------------------
-- Table `chunkMap`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `chunkMap` (
  `worker` VARCHAR(256) NOT NULL COMMENT 'A unique identifier of a worker hosting the chunk replica',
  `database` VARCHAR(256) NOT NULL COMMENT 'The name of a database',
  `table` VARCHAR(256) NOT NULL COMMENT 'The name of a table',
  `chunk` INT UNSIGNED NOT NULL COMMENT 'The number of a chunk',
  `size` BIGINT UNSIGNED NOT NULL COMMENT 'The size of a chunk')
ENGINE = InnoDB
COMMENT = 'Chunk disposition across workers';

-- -----------------------------------------------------
-- Table `chunkMapStatus`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `chunkMapStatus` (
  `update_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 'The most recent update time of the map')
ENGINE = InnoDB
COMMENT = 'Satus info on the chunk map';

-- Update version on every schema change.
-- Version 0 corresponds to initial QMeta release and it had no
-- QMetadata table at all.
-- Version 1 introduced QMetadata table and altered schema for QInfo table
-- Version 2 added query progress data to ProcessList tables.
-- Version 3 added storing the result query in QMeta.
-- Version 4 increased storage capacity of the columns in the table QInfo
-- Version 5 added QMessages table.
-- Version 6 added indexes to optimize queries made by the Qserv Web Dashboard.
-- Version 7 added final row count to QInfo.
-- Version 8 replaced INT with BIGINT in the byte and row counter columns of QInfo.
-- Version 9 removed the full-text index on the query text from QInfo.
-- Version 10 redefined schema of the ProcessList tables.
-- Version 11 extended view InfoSchemaQueries to report errors on the faile queries. Added status option FAILED_LR to QInfo.status.
-- Version 12 renamed table QStatsTmp into QProgress to reflect its purpose and add a foreign key constraint to QInfo table. Drop the obsolete table QWorker.
-- Version 13 added tables chunkMap and chunkMapStatus. The tables are meant for storing persistent chunk-to-workers map.
-- Version 14 added table QProgressHistory to store the query progrerssion history
-- Version 15 fixed a definition of the view InfoSchemaProcessList to depend on QProgress instead of QStatsTmp
-- Version 16 added tables UserTables and UserTablesParams for processing and monitoring ingest requests into the user tables
INSERT INTO `QMetadata` (`metakey`, `value`) VALUES ('version', '16');
