// -*- LSST-C++ -*-
/*
 * LSST Data Management System
 *
 * This product includes software developed by the
 * LSST Project (http://www.lsst.org/).
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the LSST License Statement and
 * the GNU General Public License along with this program.  If not,
 * see <http://www.lsstcorp.org/LegalNotices/>.
 */

#ifndef LSST_QSERV_CZAR_CZARCHUNKMAP_H
#define LSST_QSERV_CZAR_CZARCHUNKMAP_H

// System headers
#include <chrono>
#include <cstdint>
#include <map>
#include <memory>
#include <mutex>
#include <string>
#include <sstream>

// Qserv headers
#include "global/clock_defs.h"
#include "util/Issue.h"

namespace lsst::qserv::qmeta {
class QMeta;
struct QMetaChunkMap;
}  // namespace lsst::qserv::qmeta

namespace lsst::qserv::czar {

class ActiveWorker;
class CzarFamilyMap;

class ChunkMapException : public util::Issue {
public:
    ChunkMapException(Context const& ctx, std::string const& msg) : util::Issue(ctx, msg) {}
};

/// This class is used to organize worker chunk table information so that it
/// can be used to send jobs to the appropriate worker and inform workers
/// what chunks they can expect to handle in shared scans.
/// The data for the maps is provided by the Replicator and stored in the
/// QMeta database.
/// When the data is changed, there is a timestamp that is updated, which
/// will cause new maps to be made by this class.
///
/// The maps generated are constant objects stored with shared pointers. As
/// such, it should be possible for numerous threads to use each map
/// simultaneously provided they have their own pointers to the maps.
/// The pointers to the maps are mutex protected to safely allow map updates.
///
/// Generated by CzarFamilyMap::_read() and CzarFamilyMap::_insertIntoMaps(...).
/// Instances of CzarChunkMap are immutable after construction. Updates replace
/// the entire CzarChunkMap object (atomic swap), so readers can access it
/// without taking a mutex. This enables high-performance, lock-free lookups
/// when routing millions of jobs to the correct worker.
///
/// The czar is expected to heavily use the
///    `getMaps() -> WorkerChunkMap -> getSharedScanChunkMap()`
/// to send jobs to workers, as that gets an ordered list of all chunks
/// the worker should handle during a shared scan.
///    `getMaps() -> ChunkMap` is expected to be more useful if there is a
///  failure and a chunk query needs to go to a different worker.
///
/// Workers failing or new workers being added is expected to be a rare event.
/// The current algorithm to split chunks between the workers tries to split
/// the work evenly. However, if a new worker is added, it's likely that
/// the new distribution of chunks for shared scans will put the chunks on
/// different workers than previously, which in turn will result in the system
/// being less efficient until all the old scans are complete. If workers
/// being added or removed from the system becomes frequent, the algorithm should
/// probably change to try to maintain some chunk location consistency once
/// the system is up.
///
/// Failed workers are generally expected to come back online at some point,
/// so switches to alternate workers tend to be temporary. Workers being
/// added is expected to be permanent and is likely to cause significant
/// changes to where most jobs for particular chunks will be sent.
class CzarChunkMap {
public:
    using Ptr = std::shared_ptr<CzarChunkMap>;
    using SizeT = uint64_t;

    std::string cName(const char* func) const { return std::string("CzarChunkMap::") + func; }

    CzarChunkMap(CzarChunkMap const&) = delete;
    CzarChunkMap& operator=(CzarChunkMap const&) = delete;

    static Ptr create() { return Ptr(new CzarChunkMap()); }

    ~CzarChunkMap();

    class WorkerChunksData;

    /// Essentially a structure for storing data about which tables and workers are associated with this
    /// chunk.
    class ChunkData {
    public:
        using Ptr = std::shared_ptr<ChunkData>;
        ChunkData(int chunkId_) : _chunkId(chunkId_) {}

        std::string cName(const char* func) const {
            return std::string("ChunkData::") + func + " " + std::to_string(_chunkId);
        }
        int64_t getChunkId() const { return _chunkId; }
        SizeT getTotalBytes() const { return _totalBytes; }

        std::weak_ptr<WorkerChunksData> getPrimaryScanWorker() const { return _primaryScanWorker; }

        /// Add `worker` to the `_workerHasThisMap` to indicate that worker has a copy
        /// of this chunk.
        void addToWorkerHasThis(std::shared_ptr<WorkerChunksData> const& worker);

        /// Return a copy of _workerHasThisMap.
        std::map<std::string, std::weak_ptr<WorkerChunksData>> getWorkerHasThisMapCopy() const;

        std::string dump() const;

        friend CzarChunkMap;
        friend CzarFamilyMap;

    private:
        int64_t const _chunkId;  ///< The Id number for this chunk.
        SizeT _totalBytes = 0;   ///< The total number of bytes used by all tables in this chunk.
        std::weak_ptr<WorkerChunksData> _primaryScanWorker;  ///< The worker to be used to shared scans.

        /// Key is databaseName+tableName, value is size in bytes.
        std::map<std::pair<std::string, std::string>, SizeT> _dbTableMap;

        /// Map of workers that have this chunk
        std::map<std::string, std::weak_ptr<WorkerChunksData>> _workerHasThisMap;

        /// Add up the bytes in each table for this chunk to get `_totalBytes`
        void _calcTotalBytes();
    };

    /// Essentially a structure for storing which chunks are associated with a worker.
    class WorkerChunksData {
    public:
        using Ptr = std::shared_ptr<WorkerChunksData>;
        WorkerChunksData(std::string const& workerId) : _workerId(workerId) {}

        std::string cName(const char* func) {
            return std::string("WorkerChunksData::") + func + " " + _workerId;
        }

        /// Return the worker's id string.
        std::string const& getWorkerId() const { return _workerId; }

        /// Return the number of bytes contained in all chunks/tables to be
        /// accessed in a full table scan on this worker.
        SizeT getSharedScanTotalSize() const { return _sharedScanTotalSize; }

        /// Return true if this worker is dead, according to `ActiveWorkerMap`.
        bool isDead();

        /// Return a reference to `_sharedScanChunkMap`. A copy of the pointer
        /// to this class (or the containing map) should be held to ensure the reference.
        std::map<int, ChunkData::Ptr> const& getSharedScanChunkMap() const { return _sharedScanChunkMap; }

        std::string dump() const;

        friend CzarChunkMap;
        friend CzarFamilyMap;

    private:
        std::string const _workerId;

        /// Map of all chunks found on the worker where key is chunkId
        std::map<int, ChunkData::Ptr> _chunkDataMap;

        /// Map of chunks this worker will handle during shared scans.
        /// Since scans are done in order of chunk id numbers, it helps
        /// to have this in chunk id number order.
        /// At some point, this should be sent to workers so they
        /// can make more accurate time estimates for chunk completion.
        std::map<int, ChunkData::Ptr> _sharedScanChunkMap;

        /// The total size (in bytes) of all chunks on this worker that
        /// are to be used in shared scans.
        SizeT _sharedScanTotalSize = 0;

        /// Used to determine if this worker is alive and set
        /// when the test is made.
        std::shared_ptr<ActiveWorker> _activeWorker;
    };

    using WorkerChunkMap = std::map<std::string, WorkerChunksData::Ptr>;
    using ChunkMap = std::map<int, ChunkData::Ptr>;
    using ChunkVector = std::vector<ChunkData::Ptr>;

    /// Sort the chunks in `chunksSortedBySize` in descending order by total size in bytes.
    static void sortChunks(ChunkVector& chunksSortedBySize);

    /// Calculate the total bytes in each chunk and then sort the resulting ChunkVector by chunk size,
    /// descending.
    static void calcChunkMap(ChunkMap const& chunkMap, ChunkVector& chunksSortedBySize);

    /// Verify that all chunks belong to at least one worker and that all chunks are represented in shared
    /// scans.
    /// @throws ChunkMapException
    void verify(std::string const& familyName) const;

    std::string dumpChunkMap() const;

    static std::string dumpWorkerChunkMap(WorkerChunkMap const& wcMap);

    /// Return shared pointers to const `_chunkMap` and const `_workerChunkMap`, which should be
    /// held until finished with the data.
    std::pair<std::shared_ptr<CzarChunkMap::ChunkMap const>,
              std::shared_ptr<CzarChunkMap::WorkerChunkMap const>>
    getMaps() const {
        return {_chunkMap, _workerChunkMap};
    }

    /// Use the information from the registry to `organize` `_chunkMap` and `_workerChunkMap`
    /// into their expected formats, which also should define where a chunk is always
    /// run during shared scans.
    /// This is a critical function for defining which workers will handle which jobs.
    /// @return a vector of ChunkData::Ptr of chunks where no worker was found.
    std::shared_ptr<CzarChunkMap::ChunkVector> organize();

private:
    CzarChunkMap();

    /// Return shared pointers to `_chunkMap` and `_workerChunkMap`, which should be held until
    /// finished with the data.
    std::pair<std::shared_ptr<CzarChunkMap::ChunkMap>, std::shared_ptr<CzarChunkMap::WorkerChunkMap>>
    _getMaps() const {
        return {_chunkMap, _workerChunkMap};
    }

    /// Map of all workers and which chunks they contain.
    std::shared_ptr<WorkerChunkMap> _workerChunkMap{new WorkerChunkMap()};

    /// Map of all chunks in the system with chunkId number as the key and the values contain
    /// information about the tables in those chunks and which worker is responsible for
    /// handling the chunk in a shared scan.
    std::shared_ptr<ChunkMap> _chunkMap{new ChunkMap()};

    friend CzarFamilyMap;
};

}  // namespace lsst::qserv::czar

#endif  // LSST_QSERV_CZAR_CZARCHUNKMAP_H
