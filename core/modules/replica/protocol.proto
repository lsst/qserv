/*
 * LSST Data Management System
 * Copyright 2011-2018 LSST Corporation.
 *
 * This product includes software developed by the
 * LSST Project (http://www.lsst.org/).
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the LSST License Statement and
 * the GNU General Public License along with this program.  If not,
 * see <http://www.lsstcorp.org/LegalNotices/>.
 */

/**
 * replica.proto
 *   defines the wire-messages sent between replication controllers and
 *   worker services.
 */

package lsst.qserv.replica;


////////////////////////////////////////////////////////
//                  Request messages                  //
////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
// Protocol header sent to a worker. Any communication begins with
// sending this header and specifying a type of the request.
//
// Chunk replication requests must be followed by another message of
// the corresponding type to provide a scope of the request.
//
// Requests affecting the overall status of the service do not require
// any additional messages.

// Request types related to operations with replicas
//
enum ProtocolQueuedRequestType {

    REPLICA_CREATE   = 0;    // replicate a chunk
    REPLICA_DELETE   = 1;    // delete an existing replica of a chunk
    REPLICA_FIND     = 2;    // find out if a replica is present, and report its state
    REPLICA_FIND_ALL = 3;    // find all replicas and report their states
    TEST_ECHO        = 4;    // test the worker-side framework
    SQL              = 5;    // execute an SQL statement against the worker's database
    INDEX            = 6;    // extract and return a collection of the "secondary index" data
}

// Request types for managing above defined requests
//
enum ProtocolManagementRequestType {

    REQUEST_STATUS   = 0;   // check a status of a request
    REQUEST_STOP     = 1;   // stop a previously requested request
    REQUEST_DISPOSE  = 2;   // garbage collect the request (in-progress ones will be also stopped)
}

// Request types affecting the overall state of the worker replication service
//
enum ProtocolServiceRequestType {

    SERVICE_SUSPEND  = 0;
    SERVICE_RESUME   = 1;
    SERVICE_STATUS   = 2;
    SERVICE_REQUESTS = 3;
    SERVICE_DRAIN    = 4;
    SERVICE_RECONFIG = 5;
}

// Message header is sent next after the frame size request. A sender must
// indicate a class of a request by choosing one of a few options defined
// in 'Type', and then set the specific request in the corresponding
// optional field.
//
message ProtocolRequestHeader {

    /// The unique identifier of a request
    required string id = 1;

    // The request type selector determines which class of the below specified
    // optional subtypes to use
    enum RequestType {
        QUEUED  = 0;
        REQUEST = 1;
        SERVICE = 2;
    }
    required RequestType type = 2;

    // Subtypes of requests

    optional ProtocolQueuedRequestType     queued_type     = 3;
    optional ProtocolManagementRequestType management_type = 4;
    optional ProtocolServiceRequestType    service_type    = 5;

    /// Request expiration timeout (for queued requests only) for disposing
    /// requests regardless of their statuses. The timeout is expressed in
    /// seconds. The default value of '0' means no expiration for a request.
    optional uint32 timeout = 6 [default = 0];

    /// The priority level (for queued requests only) may affect a position of
    /// a request relative to others in the input queue of the worker processor.
    /// Requests with higher priority levels are placed close to the head
    /// of the queue.
    optional int32 priority = 7 [default = 0];
}

//
// The type of the next message (if any) to be sent depends on  specific type of
// the operation. It should provide additional parameters of the operation.
//

// This is a replication request. The message defines a scope of the request and
// its unique identity. This message is sent once after the header.
//
message ProtocolRequestReplicate {

    required string database = 2;
    required uint32 chunk    = 3;
    required string worker   = 4;
}

// This is a replica deletion request. The message defines a scope of the request
// and its unique identity. This message is sent once after the header.
//
message ProtocolRequestDelete {

    required string database = 2;
    required uint32 chunk    = 3;
}

// This is a replica lookup request. The message defines a scope of the request
// and its unique identity. This message is sent once after the header.
//
message ProtocolRequestFind {

    required string database = 2;
    required uint32 chunk    = 3;

    /// Compute a check/control sum for each file
    required bool compute_cs = 4;
}

// This is a replica lookup request for multiple replicas. The message defines
// a scope of the request and its unique identity. This message is sent once
// after the header.
//
message ProtocolRequestFindAll {

    required string database = 2;
}

// This is a test request which, depending on its mode, would be addressed
// either instantly or be put into the Processor's queue. The desired mode
// is specified via the optional parameter 'delay'.
// This message is sent once after the header.
//
message ProtocolRequestEcho {

    /// Data to be echoed back upon the completion of the request (if successful)
    required string data = 2;

    /// The simulated processing time (milliseconds) of the request.
    /// If the delay is greater than 0 then the request will be queued for
    /// delayed processing via the Processor's queue.
    optional uint64 delay = 3 [default = 0];
}

// This message is used in the table schema definitions
message ProtocolRequestSqlColumn {
    required string name = 1;
    required string type = 2;
}

// This request is always queued.
// This message is sent once after the header for the 'SQL' request types
message ProtocolRequestSql {

    enum Type {
        QUERY = 0;
        CREATE_DATABASE = 1;
        DROP_DATABASE = 2;
        ENABLE_DATABASE = 3;    // in Qserv
        DISABLE_DATABASE = 4;   // in Qserv
        GRANT_ACCESS = 5;
        CREATE_TABLE = 6;
        DROP_TABLE = 7;
        REMOVE_TABLE_PARTITIONING = 8;
        DROP_TABLE_PARTITION = 9;
    }
    required Type type = 6;

    /// A limit for the maximum number of rows to be returned by a request.
    /// If the limit is exceeded then extended error code ProtocolStatusExt::LARGE_RESULT
    /// will be returned to a caller.
    required uint64 max_rows = 5;

    // Variable parameters of request types. Note, that a specific request would
    // only use a subset of those as needed.

    optional string query    = 2 [default = ""];    /// The query to be executed
    optional string user     = 3 [default = ""];    /// The name of a database user authorized in
                                                    /// a context of the query.
    optional string password = 4 [default = ""];    /// Database password for the user account
    optional string database = 7 [default = ""];    /// The name of a database
    optional string table    = 8 [default = ""];    /// The name of a table
    optional string engine   = 9 [default = ""];    /// The name of an MySQL engine

    /// The name of a column (if any) which will be used as a key for MySQL partitions
    optional string partition_by_column = 10 [default = ""];

    optional uint32 transaction_id = 11 [default = 0];  /// An identifier of a super-transaction which
                                                        /// corresponds to a MySQL partition to be removed

    /// table schema
    repeated ProtocolRequestSqlColumn columns = 12;

    /// A collection of tables to apply an operation upon. This parameter is used
    /// for batch processing over multiple tables.
    repeated string tables = 13;

    /// This flag is used when a request to process multiple queries is made
    optional bool batch_mode = 14 [default = false];
}

// This request is always queued.
// This message is sent once after the header for the 'INDEX' request types
message ProtocolRequestIndex {

    required string database = 2;
    required uint32 chunk    = 3;
    required bool   has_transactions = 4;

    // An identifier of a super-transaction corresponding to a MySQL partition
    // to be inspected. This parameter is used only if the above defined
    // 'has_transactions' is set to 'true'.
    required uint32 transaction_id = 5;
}

// This request is sent to stop an on-going replication (if any is still in progress).
// This message is sent once after the header.
//
message ProtocolRequestStop {

    /// an identifier of a request to be stopped
    required string id = 1;

    // A specific type of the request will affect a choice of the status
    // object returned in response. The type needs to match a value set
    // in the preceding header at: ProtocolRequestHeader::type

    optional ProtocolQueuedRequestType queued_type = 2;
}

// This request is sent to request a status of an on-going replication (if any
// is still in progress). This message is sent once after the header.
//
message ProtocolRequestStatus {

    /// an identifier of a request to be inspected
    required string id = 1;

    // A specific type of the request will affect a choice of the status
    // object returned in response. The type needs to match a value set
    // in the preceding header at: ProtocolRequestHeader::type

    optional ProtocolQueuedRequestType queued_type = 2;
}

// This request is sent to explicitly require to garbage-collect a set
// of requests. The operation will happen regardless of states of
// the requests. Requests which are still in progress will be stopped before
// being disposed. This message is sent once after the header.
//
message ProtocolRequestDispose {

    /// an identifier of a request to be disposed
    repeated string ids = 1;
}

/////////////////////////////////////////////////////////
//                  Response messages                  //
/////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////
// All response sequences begin with sending the response
// header message containing a unique identifier of the original
// request.
//
// The header must be followed by one or more messages which are
// expected by the Controller in response to a preceding
// request associated with the original request.
//
message ProtocolResponseHeader {

    /// The unique identifier of the original request to which this
    /// response is being sent.
    required string id = 1;
}

/////////////////////////////////////////////////////////////
// These messages are expected by master upon a completion of
// the corresponding replication operations.

// Performance counters (timers) of the requests.
// This message must be present in the relevant replies.
//
message ProtocolPerformance {

    /// When a request was received by a worker service
    required uint64 receive_time = 1;

    /// When request execution started by a worker service
    required uint64 start_time = 2;

    /// When request execution finished by a worker service
    required uint64 finish_time = 3;
}

// Status values returned by all request related to operations with
// replicas. Request management operations always return messages whose types
// match the return types of the corresponding (original) replica-related requests.
// Service management requests have their own set of status values.
//
enum ProtocolStatus {
    SUCCESS       = 0;
    QUEUED        = 1;
    IN_PROGRESS   = 2;
    IS_CANCELLING = 3;
    BAD           = 4;
    FAILED        = 5;
    CANCELLED     = 6;
}
enum ProtocolStatusExt {
    NONE          = 0;
    INVALID_PARAM = 1;
    INVALID_ID    = 2;
    DUPLICATE     = 3;
    FOLDER_STAT   = 4;
    FOLDER_CREATE = 5;
    FILE_STAT     = 6;
    FILE_SIZE     = 7;
    FOLDER_READ   = 8;
    FILE_READ     = 9;
    FILE_ROPEN    = 10;
    FILE_CREATE   = 11;
    FILE_OPEN     = 12;
    FILE_RESIZE   = 13;
    FILE_WRITE    = 14;
    FILE_COPY     = 15;
    FILE_DELETE   = 16;
    FILE_RENAME   = 17;
    FILE_EXISTS   = 18;
    SPACE_REQ     = 19;
    NO_FOLDER     = 20;
    NO_FILE       = 21;
    NO_ACCESS     = 22;
    NO_SPACE      = 23;
    FILE_MTIME    = 24;
    MYSQL_ERROR   = 25;
    LARGE_RESULT  = 26;
    NO_SUCH_TABLE = 27;
    NOT_PARTITIONED_TABLE = 28;
    NO_SUCH_PARTITION = 29;
    MULTIPLE = 30;
    OTHER_EXCEPTION = 31;
}

message ProtocolFileInfo {

    /// The name of a file
    required string name = 1;

    /// Size in bytes
    required uint64 size = 2;

    /// Control sum (if available)
    required string cs = 3;

    /// The file content modification time in seconds (since UNIX Epoch)
    required uint32 mtime = 4;

    // The following parameters are set in the relevant contexts only.
    // Otherwise they'll be set to some default value)

    /// When the file migration started (where applies)
    optional uint64 begin_transfer_time = 5 [default = 0];

    /// When the file migration finished (where applies)
    optional uint64 end_transfer_time = 6 [default = 0];

    /// The size of an input file (where applies)
    optional uint64 in_size = 7 [default = 0];
}

message ProtocolReplicaInfo {
    enum ReplicaStatus {
        NOT_FOUND  = 0;
        CORRUPT    = 1;
        INCOMPLETE = 2;
        COMPLETE   = 3;
    }
    required ReplicaStatus status   = 1;
    required string        worker   = 2;
    required string        database = 3;
    required uint32        chunk    = 4;

    /// File-specific information (if available)
    repeated ProtocolFileInfo file_info_many = 5;

    /// When the replica status was obtained by a worker
    required uint64 verify_time = 6;
}

message ProtocolResponseReplicate {

    /// The completion status of the operation
    required ProtocolStatus status = 1;

    /// Extended status of this operation
    optional ProtocolStatusExt status_ext = 2 [default = NONE];

    /// The field is set for duplicate requests only
    optional string duplicate_request_id = 3 [default = ""];

    /// The performance of this operation
    required ProtocolPerformance performance = 4;

    // ------------------------------------------------------------------
    // The following optional fields are set upon a successful completion
    // of the request
    // ------------------------------------------------------------------

    /// The performance of the target operation. This field represents
    /// stats of the replica creation request obtained by the request
    /// management operations.
    optional ProtocolPerformance target_performance = 5;

    /// Extended information on the replica
    optional ProtocolReplicaInfo replica_info = 6;

    /// Parameters of the original request to which this response
    /// is related.
    optional ProtocolRequestReplicate request = 7;
}

message ProtocolResponseDelete {

    /// The completion status of the operation
    required ProtocolStatus status = 1;

    /// Extended status of this operation
    optional ProtocolStatusExt status_ext = 2 [default = NONE];

    /// The field is set for duplicate requests only
    optional string duplicate_request_id = 3 [default = ""];

    /// The performance of this operation
    required ProtocolPerformance performance = 4;

    // ------------------------------------------------------------------
    // The following optional fields are set upon a successful completion
    // of the request
    // ------------------------------------------------------------------

    /// The performance of the target operation. This field represents
    /// stats of the replica deletion request obtained by the request
    /// management operations
    optional ProtocolPerformance target_performance = 5;

    /// Extended information on the request
    optional ProtocolReplicaInfo replica_info = 6;

    /// Parameters of the original request to which this response
    /// is related
    optional ProtocolRequestDelete request = 7;

}

message ProtocolResponseFind {

    /// The completion status of the operation
    required ProtocolStatus status = 1;

    /// Extended status of this operation
    optional ProtocolStatusExt status_ext = 2 [default = NONE];

    /// The performance of this operation
    required ProtocolPerformance performance = 3;

    // ------------------------------------------------------------------
    // The following optional fields are set upon a successful completion
    // of the request
    // ------------------------------------------------------------------

    /// The performance of the target operation. This field represents
    /// stats of the replica deletion request obtained by the request
    /// management operations
    optional ProtocolPerformance target_performance = 4;

    /// Extended information on the request
    optional ProtocolReplicaInfo replica_info = 5;

    /// Parameters of the original request to which this response
    /// is related
    optional ProtocolRequestFind request = 6;
}

message ProtocolResponseFindAll {

    /// The completion status of the operation
    required ProtocolStatus status = 1;

    /// Extended status of this operation
    optional ProtocolStatusExt status_ext = 2 [default = NONE];

    /// The performance of this operation
    required ProtocolPerformance performance = 3;

    /// The performance of the target operation. This field represents
    /// stats of the replicas lookup request obtained by the request
    /// management operations
    optional ProtocolPerformance target_performance = 4;

    /// Extended information on the request
    repeated ProtocolReplicaInfo replica_info_many = 5;

    // ------------------------------------------------------------------
    // The following optional fields are set upon a successful completion
    // of the request
    // ------------------------------------------------------------------

    /// Parameters of the original request to which this response
    /// is related
    optional ProtocolRequestFindAll request = 6;
}

///////////////////////////////////////////////////////////////////
// The message returned in response to the worker testing requests.

message ProtocolResponseEcho {

    /// The completion status of the operation
    required ProtocolStatus status = 1;

    /// Extended status of this operation
    optional ProtocolStatusExt status_ext = 2 [default = NONE];

    /// The performance of this operation
    required ProtocolPerformance performance = 3;

    // -----------------------------------------------------------------
    // The following optional field are set upon a successful completion
    // of the request
    // -----------------------------------------------------------------

    /// The performance of the target operation. This field represents stats
    /// of the test request obtained by the request management operations.
    optional ProtocolPerformance target_performance = 4;

    /// Extended information on the request
    optional string data = 5;

    /// Parameters of the original request to which this response is related
    optional ProtocolRequestEcho request = 6;
}

/////////////////////////////////////////////////////////////////////
// The messages returned in response to an SQL query executed against 
// the worker's database

/// This message captures fields from MYSQL_FIELD

message ProtocolResponseSqlField {
                                        // C lang type(s)         Description
                                        // --------------------   ---------------------------------------------
    required string name       =  1;    // char*, unsigned int    The name of the column
    required string org_name   =  2;    // char*, unsigned int    The original name of the column
    required string table      =  3;    // char*, unsigned int    The name of the table
    required string org_table  =  4;    // char*, unsigned int    The original name of the table
    required string db         =  5;    // char*, unsigned int    The name of the database (schema)
    required string catalog    =  6;    // char*, unsigned int    The catalog name (always 'def')
    required string def        =  7;    // char*, unsigned int    default value
    required uint32 length     =  8;    // unsigned int           The length (width) of the column definition
    required uint32 max_length =  9;    // unsigned int           The maximum length of the column value
    required uint32 flags      = 10;    // unsigned int           Flags
    required uint32 decimals   = 11;    // unsigned int           Number of decimals
    required int32  type       = 12;    // enum enum_field_types  Field type. See all known types at:
                                        //                        https://dev.mysql.com/doc/refman/8.0/en/c-api-data-structures.html
}

/// The message representing data of a row from a result set
message ProtocolResponseSqlRow {

    /// An array of the raw (non-null terminated) byte strings, where each string
    /// represents a cell.
    /// Note that the number of elements in the array must match
    /// the number of fields.
    repeated bytes cells = 1;

    /// An array of the boolean flags indicating at which position a value
    /// of the corresponding cell has SQL NULL.
    /// Note that the number of elements in the array must match
    /// the number of fields.
    repeated bool nulls = 2;
}

message ProtocolResponseSqlResultSet {

    /// This parameter defines a scope of an operation over a worker database,
    /// and its meaning varies depending on the operation. It could be the name
    /// of a table, the name of a database, or a query. 
    optional string scope = 1 [default = ""];

    /// Extended status of an operation in a scope of a query. It needs to be
    /// explicitly set for queries with a different outcome (if they succeeded
    /// or failed due to a specific problem). The successful completion of a query
    /// is indicated by status set to NONE.
    optional ProtocolStatusExt status_ext = 2 [default = MYSQL_ERROR];

    /// MySQL-specific error (if any)
    optional string error = 3 [default = ""];

    /// Of the connection
    optional string char_set_name = 4 [default = ""];

    /// The request produced a result set
    optional bool has_result = 5;

    /// A vector with field definitions from a result set,
    /// where the number of objects in the array represents
    /// the "width" of the result set
    repeated ProtocolResponseSqlField fields = 6;

    /// An array of rows from a result set,
    /// where the number of elements in the array represents
    /// the number of rows.
    repeated ProtocolResponseSqlRow rows = 7;
}

message ProtocolResponseSql {

    /// The completion status of the operation
    required ProtocolStatus status = 1;

    /// Extended status of an operation
    optional ProtocolStatusExt status_ext = 2 [default = NONE];

    /// The performance of this operation
    required ProtocolPerformance performance = 3;

    // -----------------------------------------------------------------
    // The following optional field are set upon a successful completion
    // of the request
    // -----------------------------------------------------------------

    /// The performance of the target operation. This field represents stats
    /// of the test request obtained by the request management operations.
    optional ProtocolPerformance target_performance = 4;

    // Extended information on the request

    /// Result sets for the operations
    repeated ProtocolResponseSqlResultSet result_sets = 11;

    /// Parameters of the original request to which this response is related
    optional ProtocolRequestSql request = 10;
}

message ProtocolResponseIndex {

    /// The completion status of the operation
    required ProtocolStatus status = 1;

    /// Extended status of this operation
    optional ProtocolStatusExt status_ext = 2 [default = NONE];

    /// The performance of this operation
    required ProtocolPerformance performance = 3;

    // ------------------------------------------------------------------
    // The following optional fields are set upon a successful completion
    // of the request
    // ------------------------------------------------------------------

    /// The performance of the target operation. This field represents
    /// stats of the original request obtained by the request
    /// management operations
    optional ProtocolPerformance target_performance = 4;

    /// MySQL-specific error
    optional string error = 5 [default = ""];

    /// Full content of the TSV/CSV file in which is lines has a set of fields
    /// to be ingested into the secondary index at Qserv master. The number and
    /// a schema of fields depends on a mode the request was made as well as on
    /// a mode of the request. For consolidated (not MySQL partitioned tables)
    /// each line of the file would be represented by the triplet:
    ///
    ///   <object-id> <chunk-id> <sub-chunk-id>
    ///
    /// An for the MySQL partitioned tables it would be the quadruplet:
    ///
    ///   <super-transaction-id> <object-id> <chunk-id> <sub-chunk-id>
    ///
    required bytes data = 6;

    /// Parameters of the original request to which this response
    /// is related
    optional ProtocolRequestIndex request = 7;
}

message ProtocolResponseDisposeStatus {
    required string id = 1;
    required bool disposed = 2; 
}

message ProtocolResponseDispose {
    repeated ProtocolResponseDisposeStatus ids = 1;
}

/////////////////////////////////////////////////////////////////////////
// The message returned in response to requests related to (or affecting)
// the overall state of the server-side replication service.

message ProtocolServiceResponseInfo {

    /// Replication related requests only
    required ProtocolQueuedRequestType queued_type = 1;

    required string id       = 2;
    required int32  priority = 3;
}

message ProtocolServiceResponse {

    /// Completion status of the operation
    enum Status {
        SUCCESS = 0;
        FAILED  = 1;
    }
    required Status status = 1;
    required ProtocolPerformance performance = 2;

    enum ServiceState {
        SUSPEND_IN_PROGRESS = 0;
        SUSPENDED           = 1;
        RUNNING             = 2;
    }
    required ServiceState service_state = 3;
    required string       technology    = 4;

    /// When the service started (milliseconds since UNIX Epoch)
    required uint64 start_time = 5;

    // Counters for requests known to the service since its last start

    required uint32 num_new_requests         = 6;
    required uint32 num_in_progress_requests = 7;
    required uint32 num_finished_requests    = 8;

    // Optional (depending on a request) collections of requests in each queue

    repeated ProtocolServiceResponseInfo new_requests         =  9;
    repeated ProtocolServiceResponseInfo in_progress_requests = 10;
    repeated ProtocolServiceResponseInfo finished_requests    = 11;
}

////////////////////////////////////////////
//         The FileServer protocol        //
////////////////////////////////////////////

message ProtocolFileRequest {

    /// The name of a database
    required string database = 1;

    /// The name of a file (including its extension and excluding any path)
    required string file = 2;

    /// Tell the server to begin sending file content immediately
    /// after sending the response message. Otherwise the server will just
    /// close a connection.
    required bool send_content = 3;
}

message ProtocolFileResponse {

    /// The flag indicating if the earlier requested file is available,
    /// and it can be read by the server.
    required bool available = 1;

    /// The file size (bytes)
    required uint64 size = 2;

    /// The file content modification time in seconds (since UNIX Epoch)
    required uint32 mtime = 3;

}

//////////////////////////////////////////////
//         The IngestServer protocol        //
//////////////////////////////////////////////

/// Sent once by a client after establishing a connection with a server
message ProtocolIngestHandshakeRequest {

    /// An identifier of a super-transaction
    required uint32 transaction_id = 1;

    /// The base name (no chunk numbers or 'overlap' suffixes) of table to be loaded
    required string table = 2;

    /// The chunk number
    required uint32 chunk = 3;

    /// The flag indicating if this is the chunk 'overlap' table
    required bool is_overlap = 4;

    /// A character separating columns within a row
    enum ColumnSeparator {
        COMMA = 0;
        TAB   = 1;
    }
    required ColumnSeparator column_separator = 5;
}

/// A message which is meant for sending rows to a server after receiving
/// status READY_TO_READ_DATA. This message is sent once after each READY_TO_READ_DATA.
/// When sending the last batch of rows the client should set the flag 'last' to
/// to tell the server that no more data are available. In that case the server
/// should respond with FINISHED. Then both parties should close the connection.
message ProtocolIngestData {
    repeated bytes rows = 1;
    required bool last = 2;     /// 'true' if this was the last batch of rows
}

/// The response message sent by a server on each client's request
message ProtocolIngestResponse {

    enum Status {
        READY_TO_READ_DATA = 0;     /// server is waiting for data
        FINISHED           = 1;     /// a confirmation that the file content accepted
        FAILED             = 2;     /// to report problems
    }
    required Status status = 1;

    optional uint32 max_rows = 2 [default = 1]; /// sent with READY_TO_READ_DATA
    optional string error = 3 [default = ""];   /// sent with FAILED
}
