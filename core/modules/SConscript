# -*- python -*-
# Qserv core/modules SConscript
#
# Setup our environment
#
Import('*')
import glob, os, re, sys
import state
from itertools import chain, izip, repeat
from collections import defaultdict
import SCons.Util
import detect # Qserv dep detector
import cctarget # default cc builder
import genversion # autogenerated version headers

# Describe what your package contains here.
env.Help("""
Qserv core code
""")

# TODO:
#  * Make the configure-check optional.
###
###
extraSrcs = {} # Per-module Extra sources (if other srcs are for shared module)
extraTgts = {} # Other build outputs, e.g., distribution 'dist', etc.
extraTgts['dist'] = []
custom = detect.importCustom(env, extraTgts)

detect.checkTwisted()

# Environment
# Must do all env modifiers here, otherwise SCons complains
# about different environments used to build files in shared components.
if not env.GetOption('clean'):

    detect.addExtern(env, ARGUMENTS.get('extern', None))

    canBuild = detect.checkMySql(env) and detect.setXrootd(env) and detect.checkXrootdLink(env)
    if not canBuild:
        raise StandardError("Can't build")

    env.Append(CPPPATH=[os.getcwd()]) # top level

    state.log.debug("Scons env:\n" + env.Dump())

# all modules
allModules = """ccontrol css czar global log mysql obsolete
                parser proto proxy qana qdisp qmeta qproc query
                rproc sql sg
                tests util
                wbase wconfig wcontrol wdb wlog wpublish wsched wmgr
                xrdoss xrdsvc""".split()

# Products
def pyDistRelative(env, module):
    return os.path.join(env['python_relative_prefix'],"lsst","qserv",module)
shProducts = { "xrdoss" : {'mods' : """global mysql sql util wconfig
                                       wpublish xrdoss""".split(),
                           'libs' : """boost_regex boost_thread crypto log
                                       log4cxx mysqlclient_r ssl""".split(),
                           'distDir' : 'lib'
                           },

               "xrdsvc" : {'mods' : """global mysql proto
                                       sql util wbase
                                       wcontrol wconfig wdb wlog
                                       wpublish wsched
                                       xrdsvc""".split(),
                           'libs' : """boost_regex boost_signals boost_thread
                                       mysqlclient_r protobuf log log4cxx
                                       ssl crypto XrdSsi""".split(),
                           'distDir' : 'lib'
                           },

               "_czarLib" : {'mods' : """ccontrol czar global
                                         log
                                         parser proto
                                         qana qdisp qmeta qproc query
                                         rproc sg util""".split(),
                             'shmods' : ['css'],
                             'libs' : """ssl crypto antlr log
                                      mysqlclient_r protobuf
                                      XrdClient XrdPosix XrdSsi XrdUtils
                                      boost_regex boost_thread boost_system
                                      boost_signals zookeeper_mt""".split(),
                               'SHLIBPREFIX' : '',
                               'distDir' : pyDistRelative(env,"czar")},

               "_cssLib" : {'mods' : [],
                            'shmods' : ['css'],
                            'libs' : "log boost_thread zookeeper_mt".split(),
                            'extraSrcs' : ['css'],
                            'SHLIBPREFIX' : '',
                            'distDir' : pyDistRelative(env, "css")},

               }

# external libs for shmods
shmodLibs = {
  'css': ['log', 'log4cxx', 'boost_system', 'boost_thread', 'mysqlclient_r']
}

# extra modules to include into shmod
shmodExtraMods = {
  'css': ['sql', 'mysql']
}

# per-module set of products which will be used in building libraries
# this is usually a set of all C++ files in a module
libProducts = dict((m, None) for m in
                   chain(*[d['mods'] for d in shProducts.values()]))

# per-module set of targets for modules that use default rules
# (those modules which do not define their own SConscript)
defaultTgts = dict()

def getSrcs(mName):
    srcs = os.listdir(mName)
    return map(lambda s: os.path.join(mName, s), srcs)

def getTgts(mName):
    scriptPath = os.path.join(mName, "SConscript")
    if env.Glob(scriptPath): # os.access is faulty with VariantDir
        tgts = SConscript(scriptPath, exports={
                'env': env,
                'extraTgts': extraTgts,
                'extraSrcs' : extraSrcs,})
        return tgts
    else:
        #print "No targets for %s, using glob" % mName
        # All .cc, except test files.
        files = cctarget.getDefaultTargets(env, mName)
        defaultTgts[mName] = files
        return files

objCache = defaultdict(lambda : defaultdict(lambda : None))
def cacheObjs(env, depList, oType):
    """ caches Object() and SharedObject nodes so they can be reused,
        avoiding the scons warning for "two different environments"
    env: scons Environment
    depList: object dependencies
    oType: ".o" or ".os"
    """
    cache = objCache[id(env)]
    result = []
    for d in depList:
        (name,ext) = os.path.splitext(str(d))
        if (ext == ".cc") or (ext == ".cpp"):
            oName = name + oType
            if not cache[oName]:
                if oType == ".o": cache[oName] = env.Object(oName, d)
                elif oType == ".os": cache[oName] = env.SharedObject(oName, d)
            result.append(cache[oName])
        else: result.append(d)
    return result

boostChecker = detect.BoostChecker(env)
antlrChecker = detect.AntlrChecker(env)

def findLibs(libList):
    def cheapCheckLib(libName):
        if libName.startswith("boost"):
            return boostChecker.getLibName(libName)
        if libName.startswith("antlr"):
            return antlrChecker.getLibName(libName)
        else: return libName
    return map(cheapCheckLib, libList)

def makeSharedObjectCC(env, ccFile):
    if str(ccFile).endswith(".cc"): return env.SharedObject(ccFile)[0]
    else: return ccFile

def getTests(env, mName):
    state.log.debug("Looking for %s tests" % mName)
    scriptPath = os.path.join(mName, "SConscript.test")
    if env.Glob(scriptPath):
        tgts = SConscript(scriptPath, exports={
                'env' : env,
                'libProducts' : libProducts,
                'defaultTgts' : defaultTgts,
                'findLibs' : findLibs,
                'cacheObjs' : cacheObjs})
        return tgts
    else:
        return None

########################################################################
## Real work now.
########################################################################
# Generate version
versionFile = env.Command(['global/version.h'], None,
                          genversion.buildVersionHeader)
env.AlwaysBuild(versionFile) # Always rebuild this.

# Gather up source files
for mod in allModules:
    libProducts[mod] = getTgts(mod)

# Compute non-custom shared objects
for m in defaultTgts:
    files = defaultTgts[m]
    objs = [makeSharedObjectCC(env, a) for a in set(files)]
    defaultTgts[m] = objs

# Compute internal shlib targets
shlibs = dict()
shmods = set(chain(*[product.get('shmods', [])
                     for product in shProducts.values()]))
# Compute shared lib targets used by products
for m in shmods:
    shmodSources = libProducts[m][:]
    for extra in shmodExtraMods[m]:
        if extra in defaultTgts:
            shmodSources.extend(defaultTgts[extra])
        else:
            prods = libProducts[extra]
            if prods:
                shmodSources.extend(prods)
    shmodSources.sort(key=lambda n: n.str_for_display())
    out = env.SharedLibrary("libqserv_" + m, shmodSources, LIBS=shmodLibs[m])
    shlibs[m] = out
    for f in out:
        extraTgts['dist'].append(('lib', f))
    pass

# Compute shProduct targets
for (pkg, opts) in shProducts.items():
    srcs = []
    for m in opts['mods']: # Visit modules and compose union of LIBS
        if m in defaultTgts:
            srcs.extend(defaultTgts[m])
        else:
            prods = libProducts[m]
            if prods:
                srcs.extend(prods)
        pass
    if opts.has_key('extraSrcs'):
        srcs.extend(chain(*[extraSrcs[m] for m in opts['extraSrcs']]))

    # Eliminate dupes for srcs and libs, and
    # convert .cc to SharedObject to prevent warning
    # (scons: warning: Two different environments)
    srcs = [makeSharedObjectCC(env, a) for a in set(srcs)]
    # Sort to prevent dependency-order rebuilding
    srcs.sort(key=lambda n: n.str_for_display())

    #env.Append(LIBS=libs)
    #extLibFlags = ["-l"+lib for lib in findLibs(opts['libs'])]
    extLibs = list(findLibs(opts['libs']))
    intDeps = [] # internal dependencies on .so
    libPath = env['LIBPATH'][:] # Clone to avoid polluting env.
    if opts.has_key('shmods'):
        intDeps = [shlibs[m] for m in opts['shmods']]
        extLibs.extend(["qserv_" + s for s in opts['shmods']])
        libPath.append(os.path.dirname(intDeps[0][0].get_abspath()))
    if opts.has_key('SHLIBPREFIX'):
        out = env.SharedLibrary(pkg + ".so", srcs, LIBS=extLibs,
                                SHLIBPREFIX=opts['SHLIBPREFIX'],
                                LIBPATH=libPath)
    else:
        out = env.SharedLibrary(pkg + ".so", srcs, LIBS=extLibs,
                                LIBPATH=libPath)
    if intDeps:
        env.Requires(out, intDeps)
    env.Alias("build", out)
    for f in out:
        extraTgts['dist'].append((opts['distDir'], f))

#Runner wrapper
import runner
env["PYTHONPATH"] = extraTgts["PYTHONPATH"]
target = "qsEnv.sh"
env.Command(target, None, runner.makeRunner)
extraTgts['dist'].append(('bin', env.File(target)))

# Tests

# module tests
state.log.debug("Looking for tests : %s" % map(str, libProducts))
testTgts=[]
for m in libProducts.keys():
    tgts = getTests(env, m)
    if tgts: testTgts.extend(Flatten(tgts))

# unit tests to run
utests = env.get('UNIT_TESTS', [])
if utests:
    # all unit tests run after build target
    env.Requires(utests, "build")
    state.log.debug("Unit tests to run: %s" % map(str, utests))
    # special builder that checks that unit tests were successful
    utestCheck = env.UnitTestCheck('unit-test-check-tag', utests)
    testTgts.extend(utestCheck)

installTgts = (extraTgts['dist'], testTgts)

Return('installTgts')
