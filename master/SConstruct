# -*- python -*-
#
# SConstruct for qserv/master
#
#  
# Helpful envvars:
#
# SEARCH_ROOTS : Set the include/lib search path prefixes.
#                Redhat/Fedora users will want to add "/usr" so that
#                /usr/lib64 is added.  Defaults to "/usr:/usr/local"
# MYSQL_ROOT : Search a different root for MySQL. Useful if you have a
#              MySQL build that isn't covered by SEARCH_ROOTS or if
#              you'd like to override the version(s) found in system
#              directories or SEARCH_ROOTS 
# SWIG : The path to the swig binary to use.  Use this to specify a
#        particular SWIG installation (1.3.29 is known to be faulty,
#        and is shipped with RHEL5)
#
# Xrootd-specific variables:  The builder expects a xrootd source tree
# compiled/built in-place, so the following XRD variables need to be
# specified since the tree cannot be found automatically.
# XRD_DIR : The path to the xrootd code checkout/clone (the top-level
#           xrootd directory that holds src/, lib/, configure.classic,
#           and others) 
# XRD_PLATFORM : The platform id used by xrootd for the
#                os/machine. e.g., x86_64_linux_26_dbg.  The builder
#                will check $XRD_DIR/lib/$XRD_PLATFORM for xrootd
#                libraries. 


import glob, os.path, re, sys
import errno
import distutils.sysconfig

sys.path.append("../common")
import detect_deps

### Distribution creation
def makePythonDist():
    print 'dist', distutils.sysconfig.get_python_inc()
    
if 'install' in COMMAND_LINE_TARGETS:
    makePythonDist()


##############################
## Work starts here.
##############################
env = Environment()
searchRoots = ['/usr', '/usr/local/'] # search in /usr/local by default.
if os.environ.has_key('SEARCH_ROOTS'):
    searchRoots = os.environ['SEARCH_ROOTS'].split(":")


# Start checking deps
# -------------------
hasXrootd = True
canBuild = True

# Find Scalla/xrootd directories
x = detect_deps.XrdHelper(searchRoots)
(xrd_inc, xrd_lib) = x.getXrdLibInc()
if (not xrd_inc) or (not xrd_lib):
    print >>sys.stderr, "Can't find xrootd headers or libraries"
    hasXrootd = False
else:
    print >> sys.stderr, "Using xrootd inc/lib: ", xrd_inc, xrd_lib

# Build the environment
env.Tool('swig')
env['SWIGFLAGS'] = ['-python', '-c++', '-Iinclude'],
env['CPPPATH'] = [distutils.sysconfig.get_python_inc(), 'include'],
env['SHLIBPREFIX'] = ""
env.Append(CPPPATH = ['../common/include'])
env.Append(LIBPATH = ['../common/lib']) 


def importDeps(env, f):
    fName = f+".deps"
    if os.access(fName, os.R_OK):
        deps = eval(open(fName).read()) # import dep file directly
        #print "deps", deps
        env.Append(**deps)
importDeps(env, "../common/include/lsst/qserv/worker.pb.h")
importDeps(env, "../common/include/lsst/qserv/SqlErrorObject.hh")
importDeps(env, "../common/lib/qserv_proto")

## Allow user-specified swig tool
## SWIG 1.3.29 has bugs which cause the build to fail.
## 1.3.36 is known to work.
if os.environ.has_key('SWIG'):
    env['SWIG'] = os.environ['SWIG']

searchLibs = [xrd_lib]
mysqlRoots = filter(lambda r: "mysql" in r, searchRoots)
if os.environ.has_key('MYSQL_ROOT'):
    mysqlRoots.append(os.environ['MYSQL_ROOT'])

if not mysqlRoots: # If not overridden, use general search roots.
    mysqlRoots = searchRoots

# Look for mysql sub-directories. lib64 is important on RH/Fedora
searchLibs += filter(os.path.exists, 
                     [os.path.join(r, lb, "mysql") 
                      for r in mysqlRoots for lb in ["lib","lib64"]])

detect_deps.composeEnv(env, 
                       roots=searchRoots, 
                       includes=[xrd_inc], 
                       libs=searchLibs)
env.Append(CPPPATH = ["../common/include"])
env.Append(LIBPATH = ["../common/lib"])

if hasXrootd:
    env.Append(CPPPATH = [xrd_inc])
    env.Append(LIBPATH = [xrd_lib])
env.Append(CPPFLAGS = detect_deps.XRDFLAGS + 
           [ "-g", "-pedantic", "-Wno-long-long", "-Wall"])

# Start configuration tests
conf = Configure(env)

env.Append(LIBPATH = ["../common/lib"])
if not conf.CheckLib("qserv_common", language="C++"):
    print >> sys.stderr, "Could not find qserv_common lib"
    canBuild = False
if not conf.CheckLib("qserv_proto", language="C++"):
    print >> sys.stderr, "Could not find qserv_proto lib"
    canBuild = False

# boost library reqs
if not (detect_deps.checkAddBoost(conf, "boost_thread")
        and detect_deps.checkAddBoost(conf, "boost_regex")):
    print >>sys.stderr, "FATAL: Missing boost libs (thread and regex) "
    canBuild = False


# ANTLR
foundAntlr = detect_deps.checkAddAntlr(conf)

if not foundAntlr: canBuild = False


# Close out configuration for no parse test env
parseEnv = conf.Finish()
parseEnv = parseEnv.Clone(LIBS=parseEnv["LIBS"][:])
env = parseEnv.Clone()
conf = Configure(env)

# libssl
if not detect_deps.checkAddSslCrypto(conf): canBuild = False

# MySQL
if not detect_deps.checkAddMySql(conf): canBuild = False
# XrdPosix
if not detect_deps.checkAddXrdPosix(conf):
    hasXrootd = False

env = conf.Finish()    
canBuild = canBuild and hasXrootd

if foundAntlr:
    SConscript("SConscript.antlr", exports={'env' : env})

parserSrcs = map(lambda x: os.path.join('src', x), 
                 ["AggregatePlugin.cc",
                  "AggOp.cc",
                  "parseTreeUtil.cc",
                  "sqltoken.cc",
                  "dbgParse.cc",
                  "Substitution.cc",
                  "ChunkMapping.cc",
                  "ChunkQuerySpec.cc",
                  "SqlSQL2Lexer.cpp", 
                  "SqlSQL2Parser.cpp",
                  "SelectParser.cc",
                  "QueryMapping.cc",
                  "QueryPlugin.cc",
                  "QuerySession.cc",
                  "QueryTemplate.cc",
                  "SelectList.cc",
                  "PostPlugin.cc",
                  "TablePlugin.cc",
                  "TableRefN.cc",
                  "QservRestrictorPlugin.cc",
                  "SphericalBoxStrategy.cc",
                  "FromList.cc",
                  "WhereClause.cc",
                  "BoolTerm.cc",
                  "BoolTermFactory.cc",
                  "GroupByClause.cc",
                  "HavingClause.cc",
                  "OrderByClause.cc",
                  "ColumnRefList.cc",
                  "ColumnRef.cc",
                  "ChunkSpec.cc",
                  "ParseException.cc",
                  "SelectStmt.cc",
                  "SelectFactory.cc",
                  "FromFactory.cc",
                  "ModFactory.cc",
                  "ValueExprFactory.cc",
                  "ValueExpr.cc",
                  "ValueFactorFactory.cc",
                  "ValueFactor.cc",
                  "FuncExpr.cc",
                  "WhereFactory.cc",
                  "ifaceMeta.cc", 
                  "MetadataCache.cc"
])

pyPath = 'python/lsst/qserv/master'
pyLibName = os.path.join(pyPath, '_masterLib.so')
dispatchSrcs = map(lambda x: os.path.join('src', x), 
                   ["xrdfile.cc", 
                    "thread.cc", 
                    "MmapFile.cc",
                    "TableMerger.cc",
                    "SqlInsertIter.cc",
                    "PacketIter.cc",
                    "dispatcher.cc", "xrootd.cc",
                    "AsyncQueryManager.cc",
                    "ChunkQuery.cc",
                    "WorkQueue.cc",
                    "TaskMsgFactory2.cc",
                    "Timer.cc"])

srcPaths = dispatchSrcs + [os.path.join(pyPath, 'masterLib.i')] + parserSrcs

runTrans = { 'bin' : os.path.join('bin', 'runTransactions'),
             'srcPaths' : dispatchSrcs 
             + map(lambda p: os.path.join('src',p), 
                   ["runTransactions.cc", "runTransactions_fake.cc"])
             }
# Lexer and Parser cpp files should have been generated with
# "antlr -glib DmlSQL2.g SqlSQL2.g"
testParser = { 'bin' : os.path.join('bin', 'testCppParser'),
               'srcPaths' : (parserSrcs +
                             [os.path.join("tests","testCppParser.cc")]),
               }
# testIter doesn't need all dispatchSrcs, but it's not worth optimizing.
testIter = { 'bin' : os.path.join('bin', 'testIter'),
               'srcPaths' : ( map(lambda x: os.path.join('src', x), 
                                  ["SqlInsertIter.cc",
                                   "PacketIter.cc",
                                   "Timer.cc",
                                   "xrdfile.cc"]) +
                              [os.path.join("tests","testIter.cc")])}

xrdPrecache = { 'bin' : os.path.join('bin', 'xrdPrecache'),
                'srcPaths' : map(lambda x: os.path.join('src', x), 
                                 ["xrdfile.cc", 
                                  "xrootd.cc", 
                                  "WorkQueue.cc",
                                  "xrdPrecache.cc"])}

## FIXME: need to detect Lua so we can generate a "startMysqlProxy"
## script in the installation.

def installToDist(env, targetDir, pathList, pyLib):
    pyDir = os.path.join(targetDir, *pathList)
    p = "../%s/python" % pathList[2]
    srcPyDir = os.path.join(p , *pathList)
    # install py files
    for s in env.Glob(os.path.join(srcPyDir,"*.py")):
        if s.name == "argv.py": continue # workaround Scons missing argv.py
        env.Alias("install", env.Install(pyDir, s))
    # install pylib
    if pyLib is not None:
        env.Alias("install", env.Install(pyDir, pyLib))
    # make sure path exists
    try: os.makedirs(pyDir)
    except OSError, exc: # "as" syntax not available in Python <=2.5 
        if exc.errno == errno.EEXIST:
            pass
        else: raise
    # touch init files
    for p in range(1,len(pathList)):
        plist = [targetDir] + pathList[:p] + ["__init__.py"]
        fname = os.path.join(*plist)
        open(fname, "w").close()


def installTo(env, targetDir, pyLib):
    installToDist(env, targetDir, ["lsst","qserv","master"], pyLib)
    installToDist(env, targetDir, ["lsst","qserv","meta"], None)

    #install bins
    env.Alias("install", 
              env.Install(targetDir, env.Glob(os.path.join("bin","*.py"))))
    #install proxy
    for f in ["mysqlProxy.lua", "startMySQLProxy"]:
        env.Alias("install", env.Install(targetDir, os.path.join("proxy",f)))
    
if canBuild:
    pylib = env.SharedLibrary(pyLibName, srcPaths)
    Depends(pylib, env["antlrdeps"]) # ANTLR
    Depends(pylib, env["antlrdeps"]) # 
    #env.Program(runTrans['bin'], runTrans["srcPaths"]) # Deprecated.
    parseEnv.Program(testParser['bin'], testParser["srcPaths"])
    installTo(env, "dist", pylib)

# Describe what your package contains here.
env.Help("""
LSST Query Services master server package
""")

#
# Build/install things
#
SConscript("SConscript.runner", exports='env') # Build a runner script
for d in Split("lib examples doc"):
    if os.path.isdir(d):
        try:
            SConscript(os.path.join(d, "SConscript"), exports='env')
        except Exception, e:
            print >> sys.stderr, "%s: %s" % (os.path.join(d, "SConscript"), e)

if not canBuild:
    print >>sys.stderr, "****** Fatal errors. Didn't build anything. ******"
    

# env['IgnoreFiles'] = r"(~$|\.pyc$|^\.svn$|\.o$)"




# Alias("install", [env.Install(env['prefix'], "python"),
#                   env.Install(env['prefix'], "include"),
#                   env.Install(env['prefix'], "lib"),
#                   env.InstallAs(os.path.join(env['prefix'], "doc", "doxygen"),
#                                 os.path.join("doc", "htmlDir")),
#                   env.InstallEups(os.path.join(env['prefix'], "ups"))])

# scons.CleanTree(r"*~ core *.so *.os *.o")

# #
# # Build TAGS files
# #
# files = scons.filesToTag()
# if files:
#     env.Command("TAGS", files, "etags -o $TARGET $SOURCES")

# env.Declare()
