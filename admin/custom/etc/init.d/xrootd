#!/bin/sh
#
# xrootd/cmsd	This shell script takes care of starting and stopping
#		Qserv xrootd/cmsd instances.
#
# description: xrootd is the filesystem which allow Qserv master to \
# communicate with Qserv workers.\
# It is composed of two services : xrootd and cmsd
# Note

### BEGIN INIT INFO
# Provides: xrootd cmsd
# Short-Description: start and stop xrootd/cmsd
# Description: qms is the Qserv Meta Service. It is used by Qserv master
#              in order to get accurate informations about loaded datasets.
#              Note that Qserv service won't start if QMS databse is empty.
### END INIT INFO

. %(QSERV_BASE_DIR)s/etc/init.d/qserv-functions

XROOTD_CONFIG=%(QSERV_BASE_DIR)s/etc/lsp.cf
XROOTD_INSTANCE_NAME="worker"

PID_DIR=%(QSERV_PID_DIR)s/${XROOTD_INSTANCE_NAME}
LOG_DIR=%(QSERV_LOG_DIR)s


export QSW_XRDQUERYPATH="/q"
export QSW_DBSOCK="%(MYSQLD_SOCK)s"
export QSW_MYSQLDUMP="%(QSERV_BASE_DIR)s/bin/mysqldump"
QSW_SCRATCHPATH="%(QSERV_BASE_DIR)s/tmp"
QSW_SCRATCHDB="qservScratch"
export QSW_RESULTPATH="%(XROOTD_RUN_DIR)s/result"
export LD_LIBRARY_PATH="%(XROOTD_RUN_DIR)s;%(QSERV_BASE_DIR)s/lib"


start_service() {

        local prog

	prog=${1##*/}

	pidfile=${PID_DIR}/${prog}.pid
	lockfile=%(QSERV_BASE_DIR)s/var/lock/subsys/${prog}
	BINARY=%(QSERV_BASE_DIR)s/bin/${prog}
	LOGFILE=${LOG_DIR}/${prog}.log
	[ -x ${BINARY} ] || exit 5
	[ -f ${XROOTD_CONFIG} ] || exit 6

	xrootd_cmd="\"${BINARY} -c ${XROOTD_CONFIG} -l ${LOGFILE} -n ${XROOTD_INSTANCE_NAME} &\""
	# here pid files will be created twice time : one by xrootd/cmsd and one by start()
	# but it works
	eval start -p ${pidfile} -l ${lockfile} ${prog} ${xrootd_cmd}
	retval=$?
	return $retval
}

stop_service() {

        local prog

        prog=${1##*/}

	pidfile=${PID_DIR}/${prog}.pid
	lockfile=%(QSERV_BASE_DIR)s/var/lock/subsys/${prog}

	eval stop -p $pidfile -l $lockfile $prog
	retval=$?
	return $retval
}

start_all() {
        local xrootd_started cmsd_started=0 retval=1
        start_service "xrootd"
	xrootd_started=$?
        %(COMMENT_MONO_NODE)sstart_service "cmsd"
	%(COMMENT_MONO_NODE)scmsd_started=$?
	[[ $xrootd_started && $cmsd_started ]] && retval=0
	return $retval
}

stop_all() {
        local xrootd_stopped cmsd_stopped=0 retval=1
        stop_service "xrootd"
	xrootd_stopped=$?
	%(COMMENT_MONO_NODE)sstop_service "cmsd"
	%(COMMENT_MONO_NODE)scmsd_stopped=$?
	[[ $xrootd_stopped && $cmsd_stopped ]] && retval=0
	return $retval
}

status_all () {
        RETVAL=eval "status \"xrootd\" && status \"cmsd\""
	return $RETVAL
}



# See how we were called.
case "$1" in
  start)
	start_all
	;;
  stop)
	stop_all
	;;
  status)
	status_all
	;;
  restart)
	stop_all
	start_all
	;;
  try-restart|condrestart)
	if status_all > /dev/null; then
	    stop_all
	    start_all
	fi
	;;
  *)
	echo $"Usage: $0 {start|stop|status|restart|try-restart}"
	exit 2
esac
